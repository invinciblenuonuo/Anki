# 基础、语法

## static关键字

【在函数体内】，【修饰局部变量】，其访问权限在函数内，仅初始化一次，存储于静态存储区（可通过其地址，在其他文件中访问修改，BUG！！！）

【在模块内，函数体外】，【修饰全局变量】将模块的全局变量限制在模块内部（仅供.c使用），不能跨文件共享

【在模块内】，【修饰函数】，该函数仅可被本模块调用，不能作为接口暴露给其他模块

注意：static 与 extern不可同时修饰一个变量



## const关键字

变量一旦被初始化后无法修改。

常量指针与指针常量，* (指针）和 const（常量） 谁在前先读谁 ；*象征着地址，const象征着内容；谁在前面谁就不允许改变。

```c
int * const p; //a是一个指向整型数的常指针（指针指向不可以修改，整型数（指针指向的值）可以修改）（指针常量）
<==>const p
// const 修饰指针p
*p=10;  // 指针指向的值可以修改
// p=&b;  // 指针指向被限定

const int *p; //a是一个指向常整型数的指针（指针指向可以修改，整型数（指针指向的值）不可修改）（常量指针）
<==>const *p
// const 修饰*p
// *p=10;  // 指针指向的值被限定
p=&b;  // 指针指向可以修改

const int * const a; //a是一个指向常整形数的常指针（都不可修改）

void printArray(const int *arr, int size)  //防止修改入参
const char* getString() //防止修改返回值，返回值为指针的时候
```



## volatile关键字

作用：每次从内存或对应外设寄存器中取值放入CPU寄存器通用寄存器后进行操作，防止编译器优化

详解：CPU读取数据时，会从指定地址处取值并搬运到CPU通用寄存器中处理，在不加volatile时，对于频繁的操作，编译器会将代码的汇编指令进行优化，例子如下：

```c
 // 比如要往某一地址送两指令： 
int *ip = 0x12345678; //设备地址 
*ip = 1; //第一个指令 
*ip = 2; //第二个指令
// 编译器可能优化为：
int *ip = 0x12345678; //设备地址 
*ip = 2; //第二个指令
// 造成第一条指令被忽略
volatile int *ip = 0x12345678; //设备地址 
*ip = 1; //第一个指令 
*ip = 2; //第二个指令
```

场合：寄存器、临界区访问的变量、中断函数访问的全局或static变量

Note：与Cache的区别：

- volatile是对编译器的约束，可以控制每次从RAM读取到通用寄存器，但无法控制从RAM到通用寄存器的过程（从RAM到寄存器要经过cache）。若两次被volatile修饰的读取指令过快，即使RAM中的值改变了，但由于读取过快没有更新cache，那么实际上搬运到通用寄存器的值来自于cache，此类情况下需要禁用cache。
- 编译器优化是针对于LDR命令的，从内存中读取数据到寄存器时不允许优化这一过程，而None-cache保护的是对内存数据的访问（volatile无法控制LDR命令执行后是否刷新cache）



## #define 与 const区别

| 名称    | 编译阶段                 | 安全性         | 内存占用                      | 调试     |
| ------- | ------------------------ | -------------- | ----------------------------- | -------- |
| #define | 编译的预处理阶段展开替换 | 低             | 占用代码段空间（.text）       | 无法调试 |
| const   | 编译、运行阶段           | 有数据类型检查 | 占用数据段空间（.data常量区） | 可调式   |



## 防止头文件重复引用

当程序中第一次 #include 该文件时，由于 _NAME_H 尚未定义，所以会定义 _NAME_H 并执行“头文件内容”部分的代码；当发生多次 #include 时，因为前面已经定义了 _NAME_H，所以不会再重复执行“头文件内容”部分的代码。

```c
#ifndef _NAME_H
#define _NAME_H
//头文件内容
#endif
```



## 函数调用与栈、寄存器

```c
void fun(int a, int b);
fun(1, 2);  // 调用函数时，入栈顺序为参数从右往左，从而取参数时从左往右
| 1 |
| 2 |
 —— 
```

右边的参数先入栈，存放在R0-R3中，多余4个的参数存放在任务栈中

返回值在R0寄存器



## 全局变量和局部变量区别

全局变量存储在静态存储区，局部变量存储在栈中



## 堆栈溢出原因

动态内存分配后未正确回收，内存泄漏

函数递归调用深度太深，栈深度不够



## 局部变量与全局变量重名

局部变量在栈中；全局变量在静态存储区

局部变量作用域在{}内，就近原则



## 访问内存中某地址数据

```c
// 读取
int result=*(int *)0x123456;  // 方法1

int *ptr=const(int *)0x123456;  // 方法2
int result=*ptr;

// 修改
*(int * const)(0x56a3) = 0x3344;  // 方法1

int * const ptr = (int *)0x56a3;  // 方法2
*ptr = 0x3344;
```



## 枚举类型

```c
enum DAY {
      MON=1, TUE, WED, THU, FRI, SAT, SUN
};
 
int main() {
    enum DAY day;
    day = WED;
    printf("%d",day);  // 3
    return 0;
}

enum COLOR {
	black,  // 默认为0
	white,  // 默认+1
	red
}；

enum COLOR {
	black = 1,  // 手动指定起始值
	white,
	red
}；
    
enum COLOR {
	black,  // 0
	white = 3,
	red  // 4
}；
```



## float精度

- float的精度是保证至少**7位有效数字**是准确的
- float的取值范围[-3.4028235E38, 3.4028235E38]，精确范围是[-340282346638528859811704183484516925440, 340282346638528859811704183484516925440]

[(1条消息) float的精度和取值范围_float精度_AlbertS的博客-CSDN博客](https://blog.csdn.net/albertsh/article/details/92385277)



## 结构体字节对齐

字节对齐的作用就是**规定数据在内存中的存储起始地址必须是某个特定字节数（通常是数据类型的大小）的整数倍**。

​	1.读取效率问题

以32位机为例，它每次取32个位，也就是4个字节。以int型数据为例，如果它在内存中存放的位置按4字节对齐，也就是说1个int的数据全部落在计算机一次取数的区间内，那么只需要取一次就可以了。如图2-1。如果访问未对齐的内存，处理器需要作两次内存访问，很不巧，这个int数据刚好跨越了取数的边界，这样就需要取两次才能把这个int的数据全部取到，如图2-2，这样效率也就降低了

<img src="https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/image-20230613141702785.png" alt="image-20230613141702785" style="zoom: 67%;" />

​	2.存储空间占用

排列顺序不同时占用空间也不同

<img src="https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/image-20230613142407209.png" alt="image-20230613142407209" style="zoom:80%;" />

结构体嵌套时

<img src="https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/image-20230613142516859.png" alt="image-20230613142516859" style="zoom:80%;" />

​	3. 实际使用

```c++
#pragma pack (n)  // 编译器将按照n个字节对齐；
#pragma pack()   // 恢复先前的pack设置,取消设置的字节对齐方式

#pragma pack (1)   // 1字节对齐
typedef struct TestNoAlign {
    unsigned char u8_test1;  // 1
    unsigned int u32_test2;  // 4
    double   d8_test3;  // 8
}TestNoAlign;
#pragma pack ()  // 取消

typedef struct TestAlign {
    unsigned char u8_test1;  // 1+3
    unsigned int u32_test2;  // 4
    double   d8_test3;  // 8
}TestAlign;

int main(void)
{
    printf("sizeof(TestNoAlign) is %d sizeof(TestAlign) is %d \n",
                sizeof(TestNoAlign),sizeof(TestAlign)); 
    return 0;
}

// 13 & 16
```



## 联合体

在同一地址空间中存储不同类型的数据

```c
typedef union test_u{
	int a;
    char b;
}test;

test t;
t.a = 0x12345678;

if(t.b == 0x78) {
    printf("小端\n");  // 低地址0x00000000 放低字节0x78
}
else {
    printf("大端\n");  // 低地址0x00000000 放高字节0x12
}
```

实际使用：分离高低字节

```c
union div
{
    int n;     // n中存放要进行分离高低字节的数据
    char a[4]; // 一个整形占两个字节，char占一个字节，a[2]将n分为了两部分
}test;

test.n = 0x12345678; // 寄存器赋值
TH1 = test.a[0];    // test.a[0]中存储的是低位数据 0x78
TL1 = test.a[3];    // test.a[1]中储存了test.n的高位数据 0x12
```



实际使用：寄存器定义与位域

```c
union test {
    uint32_t reg;
    struct {
        uint32_t reserve:4;  // 占用低字节的4bit
        uint32_t ctrl:4;
        uint32_t enable:5;
        uint32_t dis:3;
        uint32_t stat:1;
        uint32_t loop:7;
        uint32_t ext:2;
        uint32_t mode:6;  // 位域和为32
    }bits;
};


int main(void) {
    union test mytest;

    mytest.reg = 0xa5a5a5a5;

    printf("reg value=0x%x\n", mytest.reg);
    printf("reserve(3:0)=0x%x\n", mytest.bits.reserve);
    printf("ctrl(7:4)=0x%x\n", mytest.bits.ctrl);
    printf("enable(12:8)=0x%x\n", mytest.bits.enable);
    printf("dis(15:13)=0x%x\n", mytest.bits.dis);
    printf("stat(16:16)=0x%x\n", mytest.bits.stat);
    printf("loop(23:17)=0x%x\n", mytest.bits.loop);
    printf("ext(25:24)=0x%x\n", mytest.bits.ext);
    printf("mode(31:26)=0x%x\n", mytest.bits.mode);

    return 0;
}
```



## 取u32的某一字节

```c
// 方法1
union bit32_data {
    uint32_t data;
    struct {
        uint8_t byte0;
        uint8_t byte1;
        uint8_t byte2;
        uint8_t byte3;
    }byte;
};
union bit32_data num;
num.data = 0x12345678;
printf("byte0 = 0x%x\n", num.byte.byte0);
printf("byte1 = 0x%x\n", num.byte.byte1);
printf("byte2 = 0x%x\n", num.byte.byte2);
printf("byte3 = 0x%x\n", num.byte.byte3);

// 方法2
#define GET_LOW_BYTE0(x) ((x >>  0) & 0x000000ff) /* 获取第0个字节 */低
#define GET_LOW_BYTE1(x) ((x >>  8) & 0x000000ff) /* 获取第1个字节 */
#define GET_LOW_BYTE2(x) ((x >> 16) & 0x000000ff) /* 获取第2个字节 */
#define GET_LOW_BYTE3(x) ((x >> 24) & 0x000000ff) /* 获取第3个字节 */高

 unsigned int a = 0x12345678;
 printf("byte0 = 0x%x\n", GET_LOW_BYTE0(a));
 printf("byte1 = 0x%x\n", GET_LOW_BYTE1(a));
 printf("byte2 = 0x%x\n", GET_LOW_BYTE2(a));
 printf("byte3 = 0x%x\n", GET_LOW_BYTE3(a));
```



## strcmp

字符串1＝字符串2，返回值＝0；
字符串2〉字符串2，返回值〉0；
字符串1〈字符串2，返回值〈0。



## 位操作

```c
#define GetBit(x , bit)   (((x) & (1 << (bit)) >> (bit))  // 获取将x的第y位（0或1）先左移再右移
#define SetBit(x , bit)   ((x) |=  (1 << (bit))  // 将X的第Y位置1
#define ClrBit(x , bit)   ((x) &= ~(1 << (bit))  // 将X的第Y位清0
```



## 寄存器操作

```c
typedef union Reg
{
    u32 Byte;
    struct
    {
        u32 a : 16; // bit [0-15]
        u32 b : 8;  // bit [16-23]
        u32 c : 1;  // bit 24
        u32 d : 4;  // bit[25-28]
        u32 e : 1;  // bit29
        u32 f : 1;  // bit30
        u32 g : 1;  // bit31
    };
} Reg;  // 占用u32大小空间

// usage
int main()
{
    Reg misc;
    
    misc.u32 = 0xffff0000;
    misc.a = 0xaa;
    printf("0x%x\n", misc.u32);
return 0;
}
// 执行结果：0xffff00aa
```





## 运算符优先级

如果一个表达式中的两个操作数具有相同的优先级，那么它们的结合律（associativity）决定它们的组合方式是从左到右或是从右到左。

<img src="https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/v2-47e3ccc5d262631d2d3f44918791f47d_720w.webp" alt="img" style="zoom:67%;" />

## *ptr++

```c
int num[] ={1,3,5,7,9};
int* ptr_num = num;

cout << *++ptr_num << endl;
//输出为 3
// 先对指针移位地址加1，然后解引用

cout << ++*ptr_num << endl;
// 输出为2
// 先解引用，再对数值+1

cout<< *ptr_num++ << " , "<< *ptr_num <<endl;
// 输出 1,3
// *与++优先级相同，右边线运算，但因为是后++，因此先解引用输出1，然后对指针++，指向第二个元素

cout << (*ptr_num)++ << " , "<< num[0] <<endl;
// 输出1,2
// 先解引用取指，修改值++

int a[5] = {0, 1, 2, 3, 4};
int *ptr = a;
printf("%d\n", *ptr);	
printf("%d\n", *ptr++);
printf("%d\n", *ptr);
printf("%d\n", *++ptr);
printf("%d\n", *ptr);
// 0 0 1 2 2
```

常用情景

```c
unsigned char Get_CRC8_Check_Sum(unsigned char *pchMessage, unsigned int dwLength, unsigned char ucCRC8) {
	unsigned char ucIndex;
    while (dwLength --) {
        ucIndex = ucCRC8^(*pchMessage++);  // 先取指针的指向的值，使用完后指针自增
        ucCRC8 = CRC8_TAB[ucIndex];
    }
	return(ucCRC8);
}
```



## 类型转换小Trick

将`uint32_t`数据赋值到`uint8_t`数组中：

```c
uint32_t data = 123;
uint8_t databuf[4] = {0};
*( (uint32_t *)databuf ) = data;//等价于memcpy(databuf, &data, 4);
```



## 比较浮点数

```c++
// float 4byte
abs(a-b) < 0.00001 1e^-5;
// double 8byte
// 判断阈值更小，16位左右
```



## 指针、数组指针、指针数组、函数指针

![94A15F94F345E8D4C2AC22BC4D1CB4E1.png](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/94A15F94F345E8D4C2AC22BC4D1CB4E1.png)

```c
int *p[10];  // 一个数组，存放有10个指针
int (*p)[10];  // 一个指针，指向长度为10的数组
int *p(int);  // 一个函数，返回int*指针
int (*p)(int);  // 一个函数指针，函数参数int，返回值int
int* (*a[10])(int)  // 一个数组，存放10个函数指针
```

```c
// 第二种的用法举例
int a[][3]={{1,2,3},{4,5,6}};
int (*p)[3];
p=a;
// 这时，p指向元素1，p+1就指向元素4
// *（*（p+1）+2）就等价于a[1][2]这个元素值
```



## 函数指针与回调函数

```c
// 回调函数案例1
int callback_1(void) {  //回调函数1主体
    printf("call_1\n");
    return 0;
};

int callback_2(void) {  //回调函数2主体
    printf("call_2\n");
    return 0;
};

//定义一个处理函数，传入的是函数指针
int Handle(int (*callback)(void)) {
    callback();  // 调用函数
}

int main()
{
    //定义两个函数指针来指向函数地址
    //不定义也可以，因为函数名称本身就是函数入口地址
    int (*call1)(void) = &callback_1;
    int (*call2)(void) = &callback_2;

    Handle(call1);  // 函数指针当参数调用
    Handle(call2);
    call1();  // 也可直接调用

    //改变函数指针指向
    call1=&callback_2;
    Handle(call1);
    return 0;
}
```



```c++
int max(int a, int b) {
	return a > b ? a : b;
}

int min(int a, int b) {
	return a < b ? a : b;
}
 
int (*f)(int, int); // 声明函数指针，指向返回值类型为int，有两个参数类型都是int的函数
 
int main(int argc, _TCHAR* argv[])
{
	f = max; // 函数指针f指向求最大值的函数max
    int c = (*f)(1, 2);
 
	printf("The max value is %d \n", c);
 
	f = min; // 函数指针f指向求最小值的函数min
    c = (*f)(1, 2);
 
	printf("The min value is %d \n", c);

	return 0;
}
```

```c
// 结构体封装函数指针
struct DEMO
{
    int x,y;
    int (*func)(int,int); //函数指针
};

int add2(int x,int y)
{
    return x+y;
}

void main()
{
    struct DEMO demo;
    demo.func = &add2;  //结构体函数指针赋值
    demo.func = add2;  //这样写也可以
    int ans = demo.func(3,4);  // 调用
}
```





## 隐式类型转换

C 语言中不同类型的数据需要转换成同一类型，才可以计算

发生情况：

```c
// 赋值转换，可能造成精度降低，不安全
double pi = 3.14;
int num = pi;
```

转换规则：

1. 转换按照数据长度增加的方向进行，以保证精度不降低。如 int 和 double相加时，int 会被隐式转换成 double 类型
2. 如果两种类型的字节数一样，且一种有符号，另一种无符号，则转换成无符号类型（例如下）

3. char 类型和 short 类型参与运算时，必须先转换成 int 类型（整型提升）

```c++
unsigned int a = 6;
int b = -20;
int c;
((a+b) > 6) ? (c=1):(c=0);

//输出是0
```

存在unsigned且数据长度一致时，会将有符号类型隐私转换为无符号类型（负数存在问题）



## 二维数组

内存模型：按行优先存储

![image-20230608215054805.png](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/image-20230608215054805.png)

```c
int Arr   [3] [4] = {{1,1,1,1},{2,2,2,2},{3,3,3,3},{4,4,4,4}};
```

<img src="https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/image-20230608215951575.png" alt="image-20230608215951575" style="zoom:67%;" />

## 数组地址+1

```c
// 一维数组
int a[5]={1,2,3,4,5};
int * ptr=(int*)(&a+1);   // &a为整个数组的地址，&a+1为数组整体大小后移的位置
*(ptr-1)  // 为数组最后一个元素的大小，=5
a++;  // 非法，a虽然是指向数组首地址的指针，但其实际为cosnt类型，指针的指向无法改变
int* p = a; p++;  // 这样合法
    
// 二维数组
int a[2][3] = {1,3,5,7,9,11};
**(a+1) = 7  // *(a+1)为a[0]+1，是第二行的首地址
```



## 双指针数组`int **a[3][4]`

```c++
int *z[3];
int **zz[3][4];

std::cout << sizeof(z) << std::endl;
std::cout << sizeof(zz) << std::endl;

//输出 3*8=24 与 4*24=96
```

 `int *array[10];`
  函数声明：`void fun(int *a[10]);`
  函数调用：`fun(array);`
  访问：使用`*(a[i]+j)`访问数组中的元素

 `int **array[10][20];`
  函数声明：`void fun(int **a[10][20]);`
  函数调用：`fun(array);`
  访问：`(*(a+i) + j)` 或者`a[i][j]`访问元素（使用双重指针表示的二维数组的访问方法）

[[(22条消息) 二维数组与双重指针_Ven_J的博客-CSDN博客_双重指针数组](https://blog.csdn.net/u013684730/article/details/46565577?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5-46565577-blog-113645091.pc_relevant_recovery_v2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5-46565577-blog-113645091.pc_relevant_recovery_v2&utm_relevant_index=10)](https://blog.csdn.net/Arcofcosmos/article/details/113645091)



## 二级指针

```c
void get(char** p, int num) {
    *p = (char*)malloc(sizeof(char) * num);
}

char *str;
get(&str,10);
strcpy(str, "hello");
std::cout << str << std::endl;
```

```c
void get(char* p, int num) {
    p = (char*)malloc(sizeof(char) * num);
}

char *str;
get(str,10);
strcpy(str, "hello");
std::cout << str << std::endl;

//ERROR
```

要改变指针指向的值，传入指针

要改变指针的指向，需要传入二级指针



## register关键字

在 C++ 中，`register` 是一种关键字，用于建议编译器将变量存储在寄存器中，以提高访问速度。然而，需要注意的是，自 C++11 标准开始，`register` 关键字已经被弃用，编译器会忽略该建议。

在早期的 C++ 标准中，`register` 关键字可以用于声明变量，以提示编译器将其存储在寄存器中。寄存器是位于 CPU 内部的一种高速内存，可以更快地访问其中的数据，而不需要像访问内存地址那样的开销。通过存储在寄存器中，可以提高对变量的访问速度，从而提高程序的性能。

使用 `register` 关键字声明变量并不意味着变量一定会被存储在寄存器中，它只是向编译器提出了一个建议。编译器会根据具体的情况（如寄存器的可用性、变量的作用域等）决定是否将变量存储在寄存器中。如果编译器无法满足这个要求，那么该变量将按照通常的方式存储在内存中。

然而，需要注意的是，现代的编译器已经非常智能化，能够基于自身的优化算法和对代码的分析，自动决定何时将变量存储在寄存器中，而无需开发人员使用 `register` 关键字进行提示。因此，即使使用 `register` 关键字，编译器也可以忽略它，根据自身的优化策略来选择最佳的存储方式。

综上所述，`register` 关键字是一种用于建议编译器将变量存储在寄存器中的关键字，但自 C++11 标准开始已经被弃用，编译器会忽略它。现代编译器已经能够自动进行寄存器分配和优化，所以在实际编程中不再需要使用 `register` 关键字。



## sizeof()

- sizeof 是在编译的时候，查找符号表，判断类型，然后根据基础类型来取值。
- 如果 sizeof 运算符的参数是一个不定长数组，则该需要在运行时计算数组长度。



## 字符设备与块设备

字符设备：操纵并读取硬件状态

块设备：存储功能，写入数据再读取，数据传输单位是扇区



## extern”C” 的作用

实现C++中正确调用C编写的模块



## 32Bit 64Bit区别

 CPU 通用寄存器的数据宽度（CPU 一次能并行处理的二进制位数）

寻址能力（32Bit仅支持4GB寻址）

![image-20221213193840246.png](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/image-20221213193840246.png)



## 大小端

STM32：小端，低地址存放低位0x12345678：低->高78 56 34 12

|                    | 大端           | 小端           |
| ------------------ | -------------- | -------------- |
| 存储方式           | 高位存在低地址 | 高位存在高地址 |
| 内存排布0x12345678 | 低地址-高地址  | 低地址-高地址  |
|                    | 12 34 56 78    | 78 56 34 12    |

<img src="https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d3d2x5ajEyMzMyMQ==,size_16,color_FFFFFF,t_70.png" alt="img" style="zoom: 67%;" />

判断方法

```c
#include<stdio.h>
union Un{
	int a;
	char b;
};
int is_little_endian1(void) {
	union Un un;
	un.a = 0x12345678;
	if(un.b == 0x78) printf("小端\r\n");
    else printf("大端\r\n");
}

int is_little_endian2(void) {
	int a = 0x12345678;
	char b = *((char *)(&a));  // 指针方式其实就是共用体的本质
	if(b == 0x78) printf("小端\r\n");
    else printf("大端\r\n");
}
```

转换方法

```c
// 变为u8类型数组后位移拼接
static inline uint32_t lfs_fromle32(uint32_t a) {
    return (((uint8_t*)&a)[0] <<  0) |
           (((uint8_t*)&a)[1] <<  8) |
           (((uint8_t*)&a)[2] << 16) |
           (((uint8_t*)&a)[3] << 24);
}
```



## 段错误

在LIinux 下C/C++中，出现段错误很多都是有指针造成的，段错误segmentation fault，信号SIGSEGV，是由于访问内存管理单元MMU异常所致，通常由于无效内存引用，如指针引用了一个不属于当前进程地址空间中的地址，操作系统便会进行干涉引发SIGSEGV信号产生段错误。

- 空指针（尝试操作地址为0的内存区域）
- 野指针（访问的内存不合法或无法察觉破坏了数据）
- 堆栈越界（同上）
- 修改了只读数据



## 为什么局部变量未定义时，每次初始化的结果是不确定的？

定义局部变量,其实就是在栈中通过移动栈指针,来给程序提供一个内存空间和这个局部变量名绑定。因为这段内存空间在栈上,而栈内存是反复使用的(脏的,上次用完没清零的) ,所以说使用栈来实现的局部变量定义时如果不初始化,里面的值就是一个垃圾值。



## printf返回值

printf的返回值就是**输出的字符数量**‘



## 可变长度数组

VLA wariable length array

在C99中，允许在函数内部（栈空间）定义可变长度数组

```c
 void test_func(int len) {
     int arr[len];
     arr[0] = 1;  // 不可在定义时初始化
 }
test_func(3);
```

![image-20230620145302115.png](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/image-20230620145302115.png)



## 变长结构体

在结构体中定义长度为0的数组，用以后续开辟变长buf，释放时仅释放结构体即可

```c++
#include <stdafx.h>
#include <iostream>
using namespace std;

const int BUF_SIZE = 100;

struct s_one {
int s_one_cnt;
char* s_one_buf;  // 用指针指向不定长buf
};
 
struct s_two {
int s_two_cnt;
char s_two_buf[0];  // 用数组指向不定长buf
};

 
int main()
{
//赋值用
constchar* tmp_buf = "abcdefghijklmnopqrstuvwxyz";
int ntmp_buf_size = strlen(tmp_buf);
 
//<1>注意s_one 与s_two的大小的不同
cout<< "sizeof(s_one) = " << sizeof(s_one) << endl; //8
cout<< "sizeof(s_two) = " << sizeof(s_two) << endl; //4
cout<< endl;
 
//为buf分配100个字节大小的空间
int ntotal_stwo_len = sizeof(s_two) + (1 + ntmp_buf_size) * sizeof(char);
 
//给s_one buf赋值
s_one* p_sone = (s_one*)malloc(sizeof(s_one));  // 开辟结构体
memset(p_sone, 0, sizeof(s_one));
p_sone->s_one_buf = (char*)malloc(1 + ntmp_buf_size);  // 开辟buf
memset(p_sone->s_one_buf, 0, 1 + ntmp_buf_size);
memcpy(p_sone->s_one_buf, tmp_buf, ntmp_buf_size);
 
//给s_two buf赋值
s_two* p_stwo = (s_two*)malloc(ntotal_stwo_len);  // 开辟结构体
memset(p_stwo, 0, ntotal_stwo_len);
memcpy((char*)(p_stwo->s_two_buf), tmp_buf, ntmp_buf_size);  //不用加偏移量，直接拷贝!
 
cout<< "p_sone->s_one_buf = " << p_sone->s_one_buf<< endl;
cout<< "p_stwo->s_two_buf = " << p_stwo->s_two_buf<< endl;
cout<< endl;
 
//<2>注意s_one 与s_two释放的不同！
if(NULL != p_sone->s_one_buf) {  // 用指针保存需要释放两次
        free(p_sone->s_one_buf);  // 释放指针
        p_sone->s_one_buf= NULL;
 
        if(NULL != p_sone) {
               free(p_sone);  // 释放结构体
               p_sone= NULL;
        }
        cout<< "free(p_sone) successed!" << endl;
}
 
if(NULL != p_stwo) {  // 结构体保存释放一次
        free(p_stwo);  // 仅释放结构体
        p_stwo= NULL;
        cout<< "free(p_stwo) successed!" << endl;
}
 
return0;
}
```



## CRC校验

循环冗余校验

一个完整的CRC参数模型应该包含以下信息：WIDTH，POLY，INIT，REFIN，REFOUT，XOROUT。通常如果只给了一个多项式，其他的没有说明则：INIT=0x00，REFIN=false，REFOUT=false，XOROUT=0x00。

- NAME：参数模型名称。
- WIDTH：宽度，即生成的CRC数据位宽，如CRC-8，生成的CRC为8位
- POLY：十六进制多项式，省略最高位1，如 x8 + x2 + x + 1，二进制为1 0000 0111，省略最高位1，转换为十六进制为0x07。
- INIT：CRC初始值，和WIDTH位宽一致。
- REFIN：true或false，在进行计算之前，原始数据是否翻转，如原始数据：0x34 = 0011 0100，如果REFIN为true，进行翻转之后为0010 1100 = 0x2c
- REFOUT：true或false，运算完成之后，得到的CRC值是否进行翻转，如计算得到的CRC值：0x97 = 1001 0111，如果REFOUT为true，进行翻转之后为11101001 = 0xE9。
- XOROUT：计算结果与此参数进行异或运算后得到最终的CRC值，和WIDTH位宽一致。

![v2-91f148259b466e4a75a10c6607370855_r.jpg](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/v2-91f148259b466e4a75a10c6607370855_r.jpg)

使用方法：

```c
#include "crcLib.h"

int main() {
    uint8_t LENGTH = 10;
    uint8_t data[LENGTH];
    uint8_t crc;

    for(int i = 0; i < LENGTH; i++) {
        data[i] = i*5;
        printf("%02x ", data[i]);
    }
    printf("\n");

    crc = crc8_maxim(data, LENGTH);

    printf("CRC-8/MAXIM:%02x\n", crc);
    return 0;
}
```

```c
//crc8 generator polynomial:G(x)=x8+x5+x4+1
const unsigned char CRC8_INIT = 0xff;
const unsigned char CRC8_TAB[256] = {
0x00, 0x5e, 0xbc, 0xe2, 0x61, 0x3f, 0xdd, 0x83, 0xc2, 0x9c, 0x7 e, 0x20, 0xa3, 0xfd, 0x1f, 0x41,
0x9d, 0xc3, 0x21, 0x7f, 0xfc, 0xa2, 0x40, 0x1e, 0x5f, 0x01, 0xe3, 0xbd, 0x3e, 0x60, 0x82, 0xdc, 0x23,
0x7d, 0x9f, 0xc1, 0x42, 0x1c, 0xfe, 0xa0, 0xe1, 0xbf, 0x5d, 0x03, 0x80, 0xde, 0x3c, 0x62, 0xbe, 0xe0,
0x02, 0x5c, 0xdf, 0x81, 0x63, 0x3d, 0x7c, 0x22, 0xc0, 0x9e, 0x1d, 0x43, 0xa1, 0xff, 0x46, 0x18, 0xfa,
0xa4, 0x27, 0x79, 0x9b, 0xc5, 0x84, 0xda, 0x38, 0x66, 0xe5, 0xbb, 0x59, 0x07, 0xdb, 0x85, 0x67,
0x39, 0xba, 0xe4, 0x06, 0x58, 0x19, 0x47, 0xa5, 0xfb, 0x78, 0x26, 0xc4, 0x9a , 0x65, 0x3b, 0xd9, 0x87,
0x04, 0x5a, 0xb8, 0xe6, 0xa7, 0xf9, 0x1b, 0x45, 0xc6, 0x98, 0x7a, 0x24, 0xf8, 0xa6, 0x44, 0x1a, 0x99,
0xc7, 0x25, 0x7b, 0x3a, 0x64, 0x86, 0xd8, 0x5b, 0x05, 0xe7, 0xb9,
0x8c, 0xd2, 0x30, 0x6e, 0xed, 0xb3, 0x51, 0x0f, 0x4e, 0x10, 0 xf2, 0xac, 0x2f, 0x71, 0x93, 0xcd, 0x11,
0x4f, 0xad, 0xf3, 0x70, 0x2e, 0xcc, 0x92, 0xd3, 0x8d, 0x6f, 0x31, 0xb2, 0xec, 0x0e, 0x50, 0xaf, 0xf1,
0x13, 0x4d, 0xce, 0x90, 0x72, 0x2c, 0x6d, 0x33, 0xd1, 0x8f, 0x0c, 0x52, 0xb0, 0xee, 0x32, 0x6c, 0x8e,
0xd0, 0x53, 0x0d, 0xef, 0xb1, 0xf0, 0xae, 0x4c, 0x12, 0x91, 0xcf, 0x2d, 0x73, 0xca, 0x94, 0x76, 0x28,
0xab, 0xf5, 0x17, 0x49, 0x08, 0x56, 0xb4, 0xea, 0x69, 0x37, 0xd5, 0x8b, 0x57, 0x09, 0xeb, 0xb5,
0x36, 0x68, 0x8a, 0xd4, 0x95, 0xcb, 0x29, 0x77, 0xf4, 0xaa, 0x48, 0x1 6, 0xe9, 0xb7, 0x55, 0x0b, 0x88,
0xd6, 0x34, 0x6a, 0x2b, 0x75, 0x97, 0xc9, 0x4a, 0x14, 0xf6, 0xa8,
0x74, 0x2a, 0xc8, 0x96, 0x15, 0x4b, 0xa9, 0xf7, 0xb6, 0xe8, 0x0a, 0x54, 0xd7, 0x89, 0x6b, 0x35,
}
// 计算CRC值
unsigned char Get_CRC8_Check_Sum(unsigned char *pchMessa ge, unsigned int dwLength, unsigned char ucCRC8) {
	unsigned char ucIndex;
    while (dwLength --) {
        ucIndex = ucCRC8^(*pchMessage++);
        ucCRC8 = CRC8_TAB[ucIndex];
    }
return(ucCRC8);
}

// 验证CRC值
/*
** Descriptions: CRC8 Verify function
** Input: Data to Verify,Stre am length = Data + checksum
** Output: True or False (CRC Verify Result)
*/
unsigned int Verify_CRC8_Check_Sum(unsigned char *pchMessage, unsigned int dwLength) {
    unsigned char ucExpected = 0;
    if ((pchMessage == 0) || (dwLength <= 2)) return 0;
    ucExpected = Get_CRC8_Check_Sum (pchMessage, dwLength 1, CRC8_INIT);
    return ( ucExpected == pchMessage[dwLength-1] );
}

/*
** Descriptions: append CRC8 to the end of data
** Input: Data to CRC and append,Stream length = Data + checksum
** Output: True or False (CRC Verify Result)
*/
void Append_CRC8_Check_Sum(unsigned char *pchMessage, unsigned int dwLength) {
    unsigned char ucCRC = 0;
    if ((pchMessage == 0) || (dwLength <= 2)) return;
    ucCRC = Get_CRC8_Check_Sum ( (unsigned char *)pc hMessage, dwLength 1, CRC8_INIT);
    pchMessage[dwLength 1] = ucCRC;
    uint16_t CRC_INIT = 0xffff;
}
```



## 奇偶校验

如果数据中1的个数为奇数，则奇校验位0，否则为1

例：1101中，1有3个，校验码为0





## 静态链接与动态链接

**静态库在链接阶段的进行组合，动态库在运行时加载**

静态链接生成的可执行文件体积较大，消耗内存，如果所使用的静态库发生更新改变，程序必须重新编译

- 静态库的链接是将整个函数库的所有数据在编译时都整合进了目标代码，最小单位是文件，因此**空间浪费，更新困难**
- 动态库的链接是程序执行到哪个函数链接哪个函数的库

动态链接库编译时的操作：

我们在形成可执行程序时，发现引用了一个外部的函数，此时会检查动态链接库，**发现这个函数名是一个动态链接符号**，此时可执行程序就**不对这个符号进行重定位**，而把这个过程留到装载时再进行。



1. 静态链接（Static Linking）：
    - 在编译时将所有的函数和库代码合并成一个可执行文件。
    - 链接是在编译段完成的，链接库和目标代码中提取所需的函数和库代码，将它们合并到最终的执行文件中 - 链接结果是一个独立的、完的可执行文件，包含了所有依赖的函数和库代码。
    - 优点：
        - 执行速度快，为所有代码已经被编译和链接在一起，无需运行时动态加载额外的库文件。
        - 可执行文件独立，可以在没有安装相应库文件的系统上运行。
    - 缺点：
        - 可执行文件较，因为所有依赖的函数和库代码都被静态链接到可执行文件中。
        - 更新和替换依赖的函数和库代码需要重新编译和链接整个程序。
2. 动态链接（Dynamic Linking）：
    - 在运行通过动态链接库在内存中加载所需的函数和库代码。
    - 链接是在运行时完成的，链接器在运程序时动态加载所需的函数和库代码。
    - 链接结果是一个可执行文件和一个或多个动态链接库，可执行文件只包含必要的启动代码和符号引用。
    - 优点：
        - 可执行文件较小，因为只包含必要的启动代码和符号引用。
        - 动态链接库可以在多个可文件之间共享，节省内存空间。
        - 更新和替换依赖的函数和库代码只需要替换对应的动态链接库。
    - 缺点：
        - 相对于静态链接，运行时需要额外的时间加载和解析动态链接库。 -中必须存在相应的动态链接库文件，否则程序无法运行。

总说，静态链接将所有的函数和库代码合并到一个可执行文件中，执行速度快，但可执行文件较大；而动态链接在运行时加载所需的函数和库代码，可执行文件较小，但可能需要额外的加载时间依赖系统存在相应的动态链接库文件。选择使用哪种方式取决于项目的需求和考虑的因素。
