# C++多线程



## pthread_create

创建子线程，并注册回调函数



## pthread_join

在主线程中调用，等待子线程执行完毕后，释放子线程资源，再执行join后的代码



## pthread_detach

主线程在调用pthread_detach(子线程ID) 与pthread_exit(NULL)后，不用等待Join才可释放子线程资源，在子线程结束运行前，主线程可以执行其他功能，子线程运行结束后资源由OS而非主线程释放

<img src="https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/image-20230306212906250.png" alt="image-20230306212906250" style="zoom:50%;" />



## pthread_cancel

在主线程中杀死子线程（通过系统调用，延迟杀死线程）



## pthread_equal

比较两个线程ID是否一致



## 父子进程fork()

当一个进程调用 `fork` 函数生成另一个进程，原进程就称为父进程，新生成的进程则称为子进程。

```c++
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main(int argc, char * argv[])
{
    int pid;
    /* fork another process */
    pid = fork();
    if (pid < 0) 
    { 
        /* error occurred */
        fprintf(stderr,"Fork Failed!");
        exit(-1);
    } 
    else if (pid == 0) 
    {
        /* child process */
        printf("This is Child Process!\n");
    } 
    else 
    {  
        /* parent process  */
        printf("This is Parent Process!\n");
        /* parent will wait for the child to complete*/
        wait(NULL);
        printf("Child Complete!\n");
    }
}
```

![image-20230704091925404.png](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/image-20230704091925404.png)

可以建立一个新进程，把当前的进程分为父进程和子进程，新进程称为子进程，而原进程称为父进程。fork调用一次，返回两次，这两个返回分别带回它们各自的返回值，其中在父进程中的返回值是子进程的PID，而子进程中的返回值则返回 0。因此，可以通过返回值来判定该进程是父进程还是子进程。





## 孤儿进程

父进程释放，子进程还在，内核接管，没有危害



## 僵尸进程

子进程退出，父进程不知道，此时子进程还占用着资源

在 Linux 环境中，我们是通过 `fork` 函数来创建子进程的。创建完毕之后，父子进程独立运行，父进程无法预知子进程什么时候结束。通常情况下，子进程退出后，父进程会使用 `wait` 或 `waitpid` 函数进行回收子进程的资源，并获得子进程的终止状态。但是，如果父进程先于子进程结束，则子进程成为孤儿进程。孤儿进程将被 init 进程（进程号为1）领养，并由 init 进程对孤儿进程完成状态收集工作。而如果子进程先于父进程退出，同时父进程太忙了，无瑕回收子进程的资源，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程

解决方案：

- 父进程在子进程退出时调用wait()/waitpid()函数来回收子进程的资源
- fork一个孙子进程，然后将子进程变为一个孤儿进程可以避免僵尸进程的产生
- 杀死这个僵尸进程的父进程。那么该僵尸进程就会被守护进程给领养。从而守护进程，会对这个僵尸进程的内核区资源进行回收。

僵尸进程其实已经就是退出的进程，因此无法再利用kill命令杀死僵尸进程。僵尸进程的罪魁祸首是父进程没有回收它的资源，那我们可以想办法它其它进程去回收僵尸进程的资源，这个进程就是 init 进程。因此，我们可以直接杀死父进程，init 进程就会很善良地把那些僵尸进程领养过来，并合理的回收它们的资源，那些僵尸进程就得到了妥善的处理了。

例如，如果 PID 5878 是一个僵尸进程，它的父进程是 PID 4809，那么要杀死僵尸进程 （5878），您可以结束父进程 （4809）：

```
$ sudo kill -9 4809  #4809 is the parent, not the zombie
```



## 守护进程

前台进程是在终端中运行的命令，那么该终端就为进程的控制终端，一旦这个终端关闭，这个进程也随着消失

- 而守护进程（Daemon），也就是我们平时说的后台进程，是运行在后台的一种特殊进程，不受终端控制，它不需要终端的交互
- 守护进程是一种特殊的后台进程，它通常在系统启动时自动启动，并在系统运行过程中一直运行，执行一些系统级别的任务，如监控系统资源、处理网络请求等。守护进程通常不与用户交互，也不需要终端，而是在后台默默地运行，直到系统关闭或者被显式地停止。



## 协程

C++20新增

协程不受操作系统调度，切换方便，轻量级

1. 依赖关系：线程是由操作系统内核进行调度管理的，并且每个线程通常拥有自己的独立堆栈和上下文。而协程则是由程序员在代码中显式地定义和管理的，没有操作系统参与调度。协程依赖于某种运行时环境或者特定的库来实现调度和切换。
2. 并发性能：线程属于操作系统层面的并发机制，它可以充分利用多核处理器的计算能力。每个线程都需要一定的系统资源来进行管理，因此**创建大量线程可能会导致资源消耗过大**。相比之下，协程是轻量级的，可以在单个线程中运行大量的协程，节省了线程切换的开销。
3. 切换机制：在**线程**之间进行**切换**时，需要进行上下文的保存和恢复，这是由操作系统**内核负责**完成的，并且通常涉及到**用户态和内核态之间的切换**。而**协程**的**切换**是在**用户态完成**的，切换开销更小。协程通过手动选择合适的切换点，在不同的协程之间进行切换，使得程序可以在合适的时机保存和恢复中间状态。
4. 同步方式：**线程**通常通过**共享内存或者消息传递**来进行通信和同步。而**协程**则通常通过**显式的调度和消息传递**机制来实现数据共享和同步。协程之间的切换是协作性的，需要各个协程自行决定何时让出执行权。

总的来说，线程更加底层和系统级别，可以充分利用多核处理器的并行计算能力，但线程数量受限于系统资源，并且线程切换开销较大。而协程是一种高级抽象，更适合处理大量的轻型任务，并且协程之间的切换开销较小。但协程需要依赖特定的运行时环境或库的支持，无法直接利用多核处理器的并行计算能力。
