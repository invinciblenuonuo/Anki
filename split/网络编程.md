# 网络编程

## OSI网络模型

| 层级 | 名称       | 作用                                             | 协议                                        | 关键词                 |
| ---- | ---------- | ------------------------------------------------ | ------------------------------------------- | ---------------------- |
| 7    | **应用层** | 各类网络服务                                     | **HTTP、FTP**                               |                        |
| 6    | 表示层     | 数据编码、格式转换、加密                         | LPP、NBSSP                                  |                        |
| 5    | 会话层     | 维护会话                                         | SSL、TLS、DAP、LDAP                         |                        |
| 4    | **传输层** | 建立主机端到端的连接（应用间的通信）             | **TCP、UDP**                                | 端口号、TCP、UDP       |
| 3    | **网络层** | 路由选择，控制数据包在设备间的转发（主机间通信） | **IP、ICMP、路由器、**RIP、IGMP、OSPF       | IP地址、路由器、ping通 |
| 2    | 数据链路层 | 将比特流封装成数据帧（数据帧、网卡间通信）       | **ARP**、**网卡**、交换机、PPTP、L2TP、ATMP | MAC地址、网卡          |
| 1    | 物理层     | 定义电平、传输介质、物理接口                     | 光纤、集线器、中继器等物理器件              |                        |



## TCP&UDP

- TCP 提供面向连接的可靠传输，UDP 提供面向无连接的不可靠传输。
- UDP 在很多实时性要求高的场景有很好的表现，而TCP在要求数据准确、对速度没有硬性要求的场景有很好的表现。

![image-20230608162934982.png](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/image-20230608162934982.png)

UDP

- 面向无连接（不需要三次握手和四次挥手）
- 尽最大努力交付、面向报文（每次收发都是一整个报文段）
- 没有拥塞控制不可靠（只管发不管过程和结果）
- 支持一对一、一对多、多对一和多对多的通信方式、首部开销很小（8字节）

优点是快，没有TCP各种机制，少了很多首部信息和重复确认的过程，节省了大量的网络资源。

缺点是不可靠不稳定，只管数据的发送不管过程和结果，网络不好的时候很容易造成数据丢失。

语音通话、视频会议等要求源主机要以恒定的速率发送数据报，允许网络不好的时候丢失一些数据，但不允许太大的延迟，UDP很适合这种要求。 

TCP

- 面向连接（需要三次握手四次挥手）
- 单播（只能端对端的连接）
- 可靠交付（有大量的机制保护TCP连接数据的可靠性）
- 全双工通讯（允许双方同时发送信息，也是四次挥手的原由）
- 面向字节流（不保留数据报边界的情况下以字节流的方式进行传输，这也是长连接的由来。）
- 头部开销大（最少20字节）

优点是可靠、稳定，有确认、窗口、重传、拥塞控制机制，在数据传完之后，还会断开连接用来节约系统资源。

缺点是慢，效率低，占用系统资源高，在传递数据之前要先建立连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接。

在要求数据准确、对速度没有硬性要求的场景有很好的表现，比如在FTP（文件传输）、HTTP/HTTPS（超文本传输），TCP很适合这种要求。



## TCP三次握手四次挥手

tcp的三次挥手的作用是保证 通信双方都能够正常的收发信息；三次握手的发生阶段是在客户端连接服务器的connect阶段开始的

1. 公安局：你好！陈某，听得到吗？（一次会话）
2. 陈某：听到了，王哥，你能听到吗 （二次会话）
3. 公安局：听到了，你过来自首吧 （开始会话）（三次会话）

<img src="https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/7bfb98fdba4740d2a5afaaef8cf9ab98.png" alt="在这里插入图片描述" style="zoom:67%;" />

1. 第一次握手 客户端发起SYN包

2. 第二次握手 服务器收到后，回复SYN+ACK包

3. 第三次握手 客户端收到后，回复ACK包

    <img src="https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/image-20230704161525182.png" alt="image-20230704161525182" style="zoom:50%;" />

有人可能会很疑惑为什么要进行第三次握手？
主要原因：防止已经失效的连接请求报文突然又传送到了服务器，从而客户端建立1个连接，服务器建立2个连接

1. 第一次握手： 客户端向服务器端发送报文
    证明客户端的发送能力正常
2. 第二次握手：服务器端接收到报文并向客户端发送报文
    证明服务器端的接收能力、发送能力正常
3. 第三次握手：客户端向服务器发送报文
    证明客户端的接收能力正常

如果采用两次握手会出现以下情况：
客户端向服务器端发送的请求报文由于网络等原因滞留，未能发送到服务器端，此时连接请求报文失效，客户端会再次向服务器端发送请求报文，之后与服务器端建立连接，当连接释放后，由于网络通畅了，第一次客户端发送的请求报文又突然到达了服务器端，这条请求报文本该失效了，但此时服务器端误认为客户端又发送了一次连接请求，两次握手建立好连接，此时客户端忽略服务器端发来的确认，也不发送数据，造成不必要的错误和网络资源的浪费。



四次挥手

作用是将服务器和客户端的连接安全的断开，四次挥手是发生在客户端或者服务器断开连接的时候

1. 张三：好的，那我先走了
2. 李四：好的，那你走吧
3. 李四：那我也走了？
4. 张三：好的，你走吧

<img src="https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/3ca4f59c07ed4c83b9ca7a16ba8344f7.png" alt="在这里插入图片描述" style="zoom:67%;" />

1. 第一次挥手 客户端发出FIN包
2. 第二次挥手 服务器收到后，发出ACK包，（此时双方还可以继续传输数据）
3. 第三次挥手 服务器发送FIN包
4. 第四次挥手 客户端收到后回复ACK包，进入超时等待状态，服务器端接收到确认报文后，会立即关闭断开

<img src="https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/image-20230704161152945.png" alt="image-20230704161152945" style="zoom:50%;" />

为什么客户端要等待2MSL？
主要原因是为了保证客户端发送那个的第一个ACK报文能到到服务器，因为这个ACK报文可能丢失，并且2MSL是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃，这样新的连接中不会出现旧连接的请求报文。当服务端一段时间后无法收到最后一个ACK包时，会重发FIN包，再次进入流程





## 浏览器从输入 URL 开始到页面显示内容，中间发生了什么？

1. DNS解析域名，获取ip端口 
2. 建立tcp链接 
3. http发送请求 
4. 服务器处理请求 
5. 服务器端返回数据
6. 浏览器解析html
7.  浏览器布局渲染



## TCP可靠传输机理

TCP是通过序列号、检验和、确认应答信号、重发机制、连接管理、窗口控制、流量控制、拥塞控制一起保证TCP传输的可靠性的。 

TCP（传输控制协议）通过以下机制来保证可靠传输：

1. 应答机制：发送方在发送数据包后，会等待接收方的确认应答。如果发送方没有收到确认应答，就会重新发送数据包，直到收到确认为止。
2. 序列号和确认号：TCP将每个数据包都赋予一个唯一的序列号，接收方收到数据包后会发送一个确认应答，并指定下一个期望接收的数据的序列号。发送方根据接收方的确认号知道哪些数据已经成功发送并被接收。
3. 滑动窗口：发送方将数据分割为多个小的数据段，并使用滑动窗口的机制进行发送。接收方通过确认号告诉发送方数据被接收，发送方可以根据确认号调整滑动窗口的大小和发送速率。
4. 重传机制：如果发送方在一定时间内未收到确认应答，就会认为数据包丢失，并进行重传。接收方在收到重复的数据包时会丢弃重复的数据，确保只有一个副本被交付给上层应用。
5. 流量控制：TCP使用滑动窗口的机制来控制发送方发送数据的速率，避免发送过多的数据导致接收方无法及时处理或丢失数据。
6. 拥塞控制：TCP根据网络的拥塞程度动态调整发送方的发送速率，避免过多的数据流入网络导致拥塞。TCP使用拥塞窗口大小和重传超时时间等参数来判断网络的拥塞情况，并采取相应的措施，如减小发送速率或等待较长时间进行重传。



##  TCP 粘包

TCP基于字节流，无法判断发送方报文段边界

造成粘包的因素有很多，有可能是发送方造成的，也有可能是接收方造成的。比如接收方在接收缓存中读取数据不及时，在下一个数据包到达之前没有读取上一个，可能也会造成读取到超过一个数据包的情况。多个数据包被连续存储于连续的缓存中，在对数据包进行读取时由于无法确定发生方的发送边界

发送端可能堆积了两次数据，每次100字节一共在发送缓存堆积了200字节的数据，而接收方在接收缓存中一次读取120字节的数据，这时候接收端读取的数据中就包括了下一个报文段的头部，造成了粘包。 

解决粘包的方法： 

- 发送方关闭Nagle算法，使用TCP_NODELAY选项关闭Nagle功能
- 发送定长的数据包。每个数据包的长度一样，接收方可以很容易区分数据包的边界
- 数据包末尾加上\r\n标记，模仿FTP协议，但问题在于如果数据正文中也含有\r\n，则会误判为消息的边界
- 数据包头部加上数据包的长度。数据包头部定长4字节，可以存储数据包的整体长度
