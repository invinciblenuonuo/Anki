# 控制算法

## PID

P：误差*Kp**【弹簧】**

I：误差*Ki后累计**【积分】**

D：当前和之前两次误差的差值*Kd（当过冲时方向相反，为负反馈阻尼）**【阻尼】**



## 串级PID

实际使用中由于电流环控制已经由电机实现，因此用户仅实现位置环和速度环

![image.png](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/image.png)

![image-20230608153852593.png](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/image-20230608153852593.png)

采用串级PID的优势与原因

【1不同工况适应性】对于不同的系统工况，由于电机实际输入是电流（直接控制转速），当电机负载不同时（原有PID参数用于平地行驶，现在爬坡行驶），电机系统模型也不同，采用同一套位置环PID算法较难获得稳定的电机电流输出信号，导致同一套参数的控制效果在其他工况变差。串级PID的引入，使得内环可以让电机速度更快地跟随。

【2系统稳态要求】若仅有位置环PID，达到指定位置时，由于没有对速度的限制，因此可能发生震荡。引入内环后速度也有PID控制器进行反馈，当位置较小时，内环的输入也会变小，从而约束稳态速度减小到0

【3限制速度】对于内环而言，可以采用输出限幅的方式限制转速，从而避免了单位置环PID在偏差较大时电机速度过快。

串级PID的参数整定基本遵循从内到外，先整定内环PID的参数，再整定外环PID的参数



```c
typedef struct {
    uint8_t mode;
    //PID 三参数
    fp32 Kp;
    fp32 Ki;
    fp32 Kd;

    fp32 max_out;  // 最大输出
    fp32 max_iout;  // 最大积分输出

    fp32 set;
    fp32 fdb;

    fp32 out;
    fp32 Pout;
    fp32 Iout;
    fp32 Dout;
    fp32 Dbuf[3];  // 微分项 0最新 1上一次 2上上次
    fp32 error[3];  // 误差项 0最新 1上一次 2上上次

} PID_t;

fp32 PID_Calc(PID_t *pid, fp32 fdb, fp32 set) {
    if (pid == NULL) {
        return 0.0f;
    }

    pid->error[2] = pid->error[1];
    pid->error[1] = pid->error[0];
    pid->set = set;
    pid->fdb = fdb;
    pid->error[0] = set - fdb;
    if (pid->mode == PID_POSITION) {
        pid->Pout = pid->Kp * pid->error[0];
        pid->Iout += pid->Ki * pid->error[0];
        pid->Dbuf[2] = pid->Dbuf[1];
        pid->Dbuf[1] = pid->Dbuf[0];
        pid->Dbuf[0] = (pid->error[0] - pid->error[1]);
        pid->Dout = pid->Kd * pid->Dbuf[0];
        LimitMax(pid->Iout, pid->max_iout);
        pid->out = pid->Pout + pid->Iout + pid->Dout;
        LimitMax(pid->out, pid->max_out);
    }
    else if (pid->mode == PID_DELTA) {
        pid->Pout = pid->Kp * (pid->error[0] - pid->error[1]);
        pid->Iout = pid->Ki * pid->error[0];
        pid->Dbuf[2] = pid->Dbuf[1];
        pid->Dbuf[1] = pid->Dbuf[0];
        pid->Dbuf[0] = (pid->error[0] - 2.0f * pid->error[1] + pid->error[2]);
        pid->Dout = pid->Kd * pid->Dbuf[0];
        pid->out += pid->Pout + pid->Iout + pid->Dout;
        LimitMax(pid->out, pid->max_out);
    }
    return pid->out;
}
```



## KF、EKF、UKF

KF能够使用的前提就是所处理的状态是满足高斯分布的，为了解决这个问题，EKF是寻找一个线性函数来近似这个非线性函数，而UKF就是去找一个与真实分布近似的高斯分布。

KF：最早提出的卡尔曼滤波算法，适用于线性系统，且系统状态和观测误差服从高斯分布。KF通过预测和更新步骤来估计系统的状态，并通过协方差矩阵来描述状态估计的不确定性。然而，KF不能很好地处理非线性系统。

EKF：扩展卡尔曼将非线性系统离散化线性化，并利用线性系统的KF进行状态估差，当非线性度较高时，EKF的估计精度可能下降。

UKF：无迹卡尔曼滤波用来解决非线性系统的问题。UKF通过选取一组称为Sigma点的采样点，保留系统的一阶矩和二阶矩，而不是线性化处理。通过这种方式，UKF能够更好地逼近非线性系统的真实分布，并提供更准确的状态估高斯系统，



## 卡尔曼滤波

用于过滤高斯噪声（白噪声）





<img src="https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70.png" alt="img" style="zoom: 50%;" />

<img src="https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/image-20221213120732933.png" alt="image-20221213120732933" style="zoom: 50%;" />

**通过k-1时刻的最优估计值预测k时刻的理论值，并根据k时刻的测量值，进行数据融合，得到k时刻的最优估计值**（线性离散时不变系统，误差正态分布）

```c
x(k) = A · x(k-1) + B · u(k) + w(k)  // 预测方程：依据k-1时刻的状态，推算k时刻的状态
z(k) = H · x(k) + y(k)  // 观测方程

x(k) —— k时刻系统的状态
u(k) —— 控制量
w(k) —— 符合高斯分布的过程噪声，其协方差在下文中为Q
z(k) —— k时刻系统的观测值
y(k) —— 符合高斯分布的测量噪声，其协方差在下文中为R
A、B、H —— 系统参数，多输入多输出时为矩阵，单输入单输出时就是几个常数
```

在后面滤波器的方程中我们将不会再直接面对两个噪声w(k)和y(k)，而是用到他们的协方差Q和R。至此，**A、B、H、Q、R**这几个参数都由被观测的系统本身和测量过程中的噪声确定了。

```c
// 时间更新（预测）
x(k|k-1) = A · x(k-1|k-1) + B · u(k)  // 系统状态(x)
P(k|k-1) = A · P(k-1|k-1) · AT + Q  // 系统协方差(P)
K(k) = P(k|k-1) · HT · (H · P(k|k-1) · HT + R)-1  // 卡尔曼增益K(k)
// 测量更新（校正融合）
x(k|k) = x(k|k-1) + K(k) · (z(k) - H · x(k|k-1))  // 输出值（后验估计）x(k|k)
P(k|k) = (I - K(k) · H) · P(k|k-1)  // 更新误差协方差
```

实际使用：

```c
x  // 观测量初始值
P  // 系统协方差
K  // 卡尔曼增益，自动计算
Q  // 过程噪声的协方差，对初值不敏感，很快收敛
R  // 测量噪声的协方差，↑后平滑但是响应变差且收敛慢
while(新观测值)
{
    K = P / (P + R);  // 增益
    x = x + K * (新观测值 - x);  // 输出
    P = (1 - K) · P + Q;  // 更新
}

float Kalman_Filter(float data) {
	static float prevData = 0;
	static float p = 1;  // 估计协方差
	static float q = 1;  // 过程噪声协方差
	static float r = 5;  // 观测噪声协方差，控制响应速率
	static float kGain = 0;
	
	p += q;
	kGain = p / (p + r);		//计算卡尔曼增益
	data = prevData + (kGain * (data - prevData));		//计算本次滤波估计值
	p = (1 - kGain) * p;		//更新测量方差
	prevData = data;
	return data;
}
```



```c
//1. 结构体类型定义
typedef struct {
    float LastP;//上次估算协方差 初始化值为0.02
    float Now_P;//当前估算协方差 初始化值为0
    float out;//卡尔曼滤波器输出 初始化值为0
    float Kg;//卡尔曼增益 初始化值为0
    float Q;//过程噪声协方差 初始化值为0.001
    float R;//观测噪声协方差 初始化值为0.543
}KFP；//Kalman Filter parameter

//2. 以高度为例 定义卡尔曼结构体并初始化参数
KFP KFP_height={0.02,0,0,0,0.001,0.543};

/*卡尔曼滤波器
 *@param KFP *kfp 卡尔曼结构体参数
 *   float input 需要滤波的参数的测量值（即传感器的采集值）
 *@return 滤波后的参数（最优值）*/
 float kalmanFilter(KFP *kfp,float input) {
     //预测协方差方程：k时刻系统估算协方差 = k-1时刻的系统协方差 + 过程噪声协方差
     kfp->Now_P = kfp->LastP + kfp->Q;
     //卡尔曼增益方程：卡尔曼增益 = k时刻系统估算协方差 / （k时刻系统估算协方差 + 观测噪声协方差）
     kfp->Kg = kfp->Now_P / (kfp->NOw_P + kfp->R);
     //更新最优值方程：k时刻状态变量的最优值 = 状态变量的预测值 + 卡尔曼增益 * （测量值 - 状态变量的预测值）
     kfp->out = kfp->out + kfp->Kg * (input -kfp->out);//因为这一次的预测值就是上一次的输出值
     //更新协方差方程: 本次的系统协方差付给 kfp->LastP 为下一次运算准备。
     kfp->LastP = (1-kfp->Kg) * kfp->Now_P;
     return kfp->out；
 }

//调用卡尔曼滤波器 实践
float height;
float kalman_height = 0;
kalman_height = kalmanFilter(&KFP_height, height);
```
