# 数据结构

## 二叉树遍历方式

1. 先(根)序遍历（根左右）
2. 中(根)序遍历（左根右）
3. 后(根)序遍历（左右根）



## 链表操作

<img src="https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/image-20221111121552317.png" alt="image-20221111121552317" style="zoom: 67%;" />



## 环形缓冲 循环队列

- 作用：FIFO，且写入数据为短时间大量，读取为低速少量但高频
- （平均读取速度一定要高于写入速度，否则多大的buf都会满）
- 主要构成：起始位置、长度、读位置、写位置

方法1：采用镜像指示位，读写越界时翻转镜像指示位

初始均为0，空；放入5个数据，读位置0不变，写位置+5后变为0+5=5

<img src="https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/image-20230605220859432.png" alt="image-20230605220859432" style="zoom: 50%;" />

尝试再次写入5个数据

此时镜像指示位write_mirror置1，表示越界了，同时读写指针均为0，表示满了

<img src="https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/image-20230605221333889.png" alt="image-20230605221333889" style="zoom:50%;" />

方法2：少利用一块数据区域，读写指针相等为空，写指针+1==读指针为满

[ring buffer，一篇文章讲透它？ - 掘金 (juejin.cn)](https://juejin.cn/post/7113550346835722276)

![img](嵌入式笔记.assets/D2B5CA33BD970F64A6301FA75AE2EB22)



```c
//队列为满的条件
(rear+1) % MaxSize == front;

//队列为空的条件
front == rear;

// 队列中元素的个数
(rear- front + maxSize) % MaxSize;

//入队
rear = (rear + 1) % maxSize;

// 出队
front = (front + 1) % maxSize;
```

当涉及到多线程时采用信号量通知，加锁互斥访问