问题,答案
"全局变量和局部变量有什么区别？","全局变量存储在静态存储区，  
局部变量存储在栈中"
"堆栈溢出的原因有哪些？","- 动态内存分配后未正确回收，内存泄漏  
- 函数递归调用深度太深，栈深度不够"
"strcmp函数的返回值如何比较两个字符串的大小？","```
字符串1＝字符串2，返回值＝0；
字符串2〉字符串2，返回值〉0；
字符串1〈字符串2，返回值〈0。
```"
"局部变量与全局变量重名时会发生什么？","- 局部变量在栈中；全局变量在静态存储区  
- 局部变量作用域在`{}`内，就近原则"
"什么是运算符优先级中的结合律（associativity）？","如果一个表达式中的两个操作数具有相同的优先级，那么它们的结合律（associativity）决定它们的组合方式是从左到右或是从右到左。  

![img](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/v2-47e3ccc5d262631d2d3f44918791f47d_720w.webp)"
"如何防止头文件被重复引用？","当程序中第一次 `#include` 该文件时，由于 `_NAME_H` 尚未定义，所以会定义 `_NAME_H` 并执行“头文件内容”部分的代码；  
当发生多次 `#include` 时，因为前面已经定义了 `_NAME_H`，所以不会再重复执行“头文件内容”部分的代码。  

```c
#ifndef _NAME_H
#define _NAME_H
//头文件内容
#endif
```"
"如何在C++中比较浮点数？","```c++
// float 4byte
abs(a-b) < 0.00001 1e^-5;
// double 8byte
// 判断阈值更小，16位左右
```"
"函数调用时参数是如何传递和存储的？返回值存放在哪里？","```c
void fun(int a, int b);
fun(1, 2);  // 调用函数时，入栈顺序为参数从右往左，从而取参数时从左往右
| 1 |
| 2 |
——
```
右边的参数先入栈，存放在R0-R3中，多余4个的参数存放在任务栈中  
返回值在R0寄存器"
"C语言中如何使用宏进行位操作？","```c
#define GetBit(x , bit)   (((x) & (1 << (bit)) >> (bit))  // 获取将x的第y位（0或1）先左移再右移  
#define SetBit(x , bit)   ((x) |=  (1 << (bit))  // 将X的第Y位置1  
#define ClrBit(x , bit)   ((x) &= ~(1 << (bit))  // 将X的第Y位清0  
```"
"#define 与 const有什么区别？","| 名称    | 编译阶段                 | 安全性         | 内存占用                      | 调试     |  
| ------- | ------------------------ | -------------- | ----------------------------- | -------- |  
| #define | 编译的预处理阶段展开替换 | 低             | 占用代码段空间（.text）       | 无法调试 |  
| const   | 编译、运行阶段           | 有数据类型检查 | 占用数据段空间（.data常量区） | 可调式   |"
"如何将`uint32_t`类型数据赋值到`uint8_t`数组中？","```c
uint32_t data = 123;
uint8_t databuf[4] = {0};
*( (uint32_t *)databuf ) = data;//等价于memcpy(databuf, &data, 4);
```"
"float的精度和取值范围是怎样的？","- float的精度是保证至少**7位有效数字**是准确的  
- float的取值范围[-3.4028235E38, 3.4028235E38]，精确范围是[-340282346638528859811704183484516925440, 340282346638528859811704183484516925440]  
[(1条消息) float的精度和取值范围_float精度_AlbertS的博客-CSDN博客](https://blog.csdn.net/albertsh/article/details/92385277)"
"static关键字在C语言中有哪些用法和注意事项？","- **在函数体内**：  
  - **修饰局部变量**：其访问权限在函数内，仅初始化一次，存储于静态存储区（可通过其地址，在其他文件中访问修改，BUG！！！）  

- **在模块内，函数体外**：  
  - **修饰全局变量**：将模块的全局变量限制在模块内部（仅供.c使用），不能跨文件共享  

- **在模块内**：  
  - **修饰函数**：该函数仅可被本模块调用，不能作为接口暴露给其他模块  

**注意**：static 与 extern不可同时修饰一个变量"
"如何在C语言中访问和修改内存中特定地址的数据？","```c
// 读取内存地址数据的方法：
// 方法1 - 直接读取
int result = *(int *)0x123456;

// 方法2 - 通过指针变量读取
int *ptr = (int *)0x123456;
int result = *ptr;

// 修改内存地址数据的方法：
// 方法1 - 直接修改
*(int * const)(0x56a3) = 0x3344;

// 方法2 - 通过指针变量修改
int * const ptr = (int *)0x56a3;
*ptr = 0x3344;
```"
"什么是枚举类型？如何在C语言中定义和使用枚举类型？","```c
enum DAY {
    MON=1, TUE, WED, THU, FRI, SAT, SUN
};
int main() {
    enum DAY day;
    day = WED;
    printf(""%d"",day);  // 3
    return 0;
}
enum COLOR {
    black,  // 默认为0
    white,  // 默认+1
    red
}；
enum COLOR {
    black = 1,  // 手动指定起始值
    white,
    red
}；
enum COLOR {
    black,  // 0
    white = 3,
    red  // 4
}；
```"
"什么是字符设备与块设备？","- **字符设备**：操纵并读取硬件状态  
- **块设备**：存储功能，写入数据再读取，数据传输单位是扇区"
"extern ""C"" 的作用是什么？","实现C++中正确调用C编写的模块"
"sizeof() 运算符的工作原理是什么？","- sizeof 是在编译的时候，查找符号表，判断类型，然后根据基础类型来取值。  
- 如果 sizeof 运算符的参数是一个不定长数组，则该需要在运行时计算数组长度。"
"printf函数的返回值是什么？","printf的返回值就是**输出的字符数量**"
"32Bit和64Bit的主要区别是什么？","- CPU 通用寄存器的数据宽度（CPU 一次能并行处理的二进制位数）  
- 寻址能力（32Bit仅支持4GB寻址）  
- ![image-20221213193840246.png](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/image-20221213193840246.png)"
"二维数组在内存中是如何存储的？","二维数组在内存中按行优先存储。  

示例代码：  
```c
int Arr [3] [4] = {{1,1,1,1},{2,2,2,2},{3,3,3,3},{4,4,4,4}};
```

内存模型示意图：  
![image-20230608215054805.png](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/image-20230608215054805.png)  

可视化存储结构：  
<img src=""https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/image-20230608215951575.png"" alt=""image-20230608215951575"" style=""zoom:67%;"" />"
"为什么局部变量未定义时，每次初始化的结果是不确定的？","定义局部变量，其实就是在栈中通过移动栈指针，来给程序提供一个内存空间和这个局部变量名绑定。  
因为这段内存空间在栈上，而栈内存是反复使用的(脏的，上次用完没清零的)，所以说使用栈来实现的局部变量定义时如果不初始化，里面的值就是一个垃圾值。"
"const关键字的作用是什么？","变量一旦被初始化后无法修改。"
"什么是二级指针？在C语言中如何使用二级指针？","```c
// 正确使用二级指针的示例：
void get(char** p, int num) {
    *p = (char*)malloc(sizeof(char) * num);
}
char *str;
get(&str,10);
strcpy(str, ""hello"");
std::cout << str << std::endl;
```

```c
// 错误示例（未使用二级指针）：
void get(char* p, int num) {
    p = (char*)malloc(sizeof(char) * num);
}
char *str;
get(str,10);
strcpy(str, ""hello"");
std::cout << str << std::endl;
//ERROR
```

关键点：  
1. 要改变指针指向的值，只需传入指针  
2. 要改变指针的指向，需要传入二级指针"
"在C语言中，数组地址+1的操作有什么特别之处？","```c
// 一维数组  
int a[5]={1,2,3,4,5};  
int * ptr=(int*)(&a+1);   // &a为整个数组的地址，&a+1为数组整体大小后移的位置  
*(ptr-1)  // 为数组最后一个元素的大小，=5  
a++;  // 非法，a虽然是指向数组首地址的指针，但其实际为cosnt类型，指针的指向无法改变  
int* p = a; p++;  // 这样合法  
// 二维数组  
int a[2][3] = {1,3,5,7,9,11};  
**(a+1) = 7  // *(a+1)为a[0]+1，是第二行的首地址  
```"
"什么是奇偶校验？","如果数据中1的个数为奇数，则奇校验位0，否则为1  
例：1101中，1有3个，校验码为0"
"什么是段错误(segmentation fault)？在Linux下C/C++中导致段错误的常见原因有哪些？","在Linux下C/C++中，段错误(segmentation fault)是指程序访问了无效内存区域时产生的错误，信号为SIGSEGV。这是由于访问内存管理单元(MMU)异常所致，通常由以下指针相关操作引发：

- 空指针（尝试操作地址为0的内存区域）  
- 野指针（访问的内存不合法或无法察觉破坏了数据）  
- 堆栈越界（同上）  
- 修改了只读数据  

当指针引用了一个不属于当前进程地址空间中的地址时，操作系统会介入并触发SIGSEGV信号，从而产生段错误。"
"什么是C语言中的隐式类型转换？","C 语言中不同类型的数据需要转换成同一类型，才可以计算。"
"什么是寄存器操作？请用C语言示例说明如何通过联合体(union)实现寄存器位域操作。","```c
typedef union Reg
{
u32 Byte;
struct
{
u32 a : 16; // bit [0-15]
u32 b : 8;  // bit [16-23]
u32 c : 1;  // bit 24
u32 d : 4;  // bit[25-28]
u32 e : 1;  // bit29
u32 f : 1;  // bit30
u32 g : 1;  // bit31
};
} Reg;  // 占用u32大小空间
// usage
int main()
{
Reg misc;
misc.u32 = 0xffff0000;
misc.a = 0xaa;
printf(""0x%x\n"", misc.u32);
return 0;
}
// 执行结果：0xffff00aa
```

解释：
1. 定义了一个联合体`Reg`，包含一个32位整数字段`Byte`和一个位域结构体
2. 位域结构体将32位寄存器划分为：
   - a: 16位 [0-15]
   - b: 8位 [16-23] 
   - c: 1位 [24]
   - d: 4位 [25-28]
   - e: 1位 [29]
   - f: 1位 [30]
   - g: 1位 [31]
3. 示例中先设置整个寄存器值为0xffff0000
4. 然后通过位域单独修改a字段为0xaa
5. 最终输出结果为0xffff00aa，验证了位域操作的正确性"
"如何从u32类型数据中提取特定字节？","有两种常用方法可以从u32类型数据中提取特定字节：

**方法1：使用联合体(union)和结构体**  
```c
union bit32_data {
    uint32_t data;
    struct {
        uint8_t byte0;
        uint8_t byte1;
        uint8_t byte2;
        uint8_t byte3;
    }byte;
};
union bit32_data num;
num.data = 0x12345678;
printf(""byte0 = 0x%x\n"", num.byte.byte0);
printf(""byte1 = 0x%x\n"", num.byte.byte1);
printf(""byte2 = 0x%x\n"", num.byte.byte2);
printf(""byte3 = 0x%x\n"", num.byte.byte3);
```

**方法2：使用位移和掩码宏**  
```c
#define GET_LOW_BYTE0(x) ((x >>  0) & 0x000000ff) /* 获取第0个字节 */低
#define GET_LOW_BYTE1(x) ((x >>  8) & 0x000000ff) /* 获取第1个字节 */
#define GET_LOW_BYTE2(x) ((x >> 16) & 0x000000ff) /* 获取第2个字节 */
#define GET_LOW_BYTE3(x) ((x >> 24) & 0x000000ff) /* 获取第3个字节 */高
unsigned int a = 0x12345678;
printf(""byte0 = 0x%x\n"", GET_LOW_BYTE0(a));
printf(""byte1 = 0x%x\n"", GET_LOW_BYTE1(a));
printf(""byte2 = 0x%x\n"", GET_LOW_BYTE2(a));
printf(""byte3 = 0x%x\n"", GET_LOW_BYTE3(a));
```"
"volatile关键字的作用是什么？","作用：每次从内存或对应外设寄存器中取值放入CPU寄存器通用寄存器后进行操作，防止编译器优化"
"什么是可变长度数组（VLA）？","VLA（Variable Length Array）是C99中引入的特性，允许在函数内部（栈空间）定义可变长度数组。  
示例代码：  
```c  
void test_func(int len) {  
int arr[len];  
arr[0] = 1;  // 不可在定义时初始化  
}  
test_func(3);  
```  
![image-20230620145302115.png](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/image-20230620145302115.png)"
"请解释指针、数组指针、指针数组、函数指针的区别，并举例说明它们的语法和用法。","```markdown
1. **指针数组**  
   ```c
   int *p[10];  // 一个数组，存放有10个指针
   ```  
   这是一个数组，数组中的每个元素都是一个`int*`类型的指针。

2. **数组指针**  
   ```c
   int (*p)[10];  // 一个指针，指向长度为10的数组
   ```  
   这是一个指针，指向一个包含10个`int`元素的数组。  
   用法举例：  
   ```c
   int a[][3]={{1,2,3},{4,5,6}};
   int (*p)[3];
   p=a;
   // 这时，p指向元素1，p+1就指向元素4
   // *（*（p+1）+2）就等价于a[1][2]这个元素值
   ```

3. **函数声明（返回指针的函数）**  
   ```c
   int *p(int);  // 一个函数，返回int*指针
   ```  
   这是一个函数声明，函数名为`p`，参数为`int`，返回值为`int*`。

4. **函数指针**  
   ```c
   int (*p)(int);  // 一个函数指针，函数参数int，返回值int
   ```  
   这是一个指针，指向一个函数，该函数的参数为`int`，返回值为`int`。

5. **函数指针数组**  
   ```c
   int* (*a[10])(int)  // 一个数组，存放10个函数指针
   ```  
   这是一个数组，数组中的每个元素都是一个函数指针，这些函数的参数为`int`，返回值为`int*`。
```"
"请解释C语言中`*ptr++`、`*++ptr`、`++*ptr`和`(*ptr)++`的区别，并给出示例代码的输出结果。","```c
int num[] ={1,3,5,7,9};
int* ptr_num = num;

// 示例1: *++ptr_num
cout << *++ptr_num << endl;
// 输出为 3
// 先对指针地址加1（指向下一个元素），然后解引用

// 示例2: ++*ptr_num
cout << ++*ptr_num << endl;
// 输出为2
// 先解引用获取当前值，再对数值+1（修改原数组的值）

// 示例3: *ptr_num++
cout<< *ptr_num++ << "" , ""<< *ptr_num <<endl;
// 输出 1,3
// *与++优先级相同，右结合运算。后++的特性：先解引用输出当前值1，然后指针++指向第二个元素

// 示例4: (*ptr_num)++
cout << (*ptr_num)++ << "" , ""<< num[0] <<endl;
// 输出1,2
// 先解引用取值，修改值++（原数组第一个元素从1变为2）

// 综合示例：
int a[5] = {0, 1, 2, 3, 4};
int *ptr = a;
printf(""%d\n"", *ptr);       // 0（指向首元素）
printf(""%d\n"", *ptr++);     // 0（先输出，后指针++）
printf(""%d\n"", *ptr);       // 1（指针已指向第二个元素）
printf(""%d\n"", *++ptr);     // 2（指针先++指向第三个元素，再解引用）
printf(""%d\n"", *ptr);       // 2（指针未移动）

// 常用情景：循环中指针自增
unsigned char Get_CRC8_Check_Sum(unsigned char *pchMessage, unsigned int dwLength, unsigned char ucCRC8) {
    unsigned char ucIndex;
    while (dwLength--) {
        ucIndex = ucCRC8^(*pchMessage++);  // 先取指针指向的值，使用完后指针自增
        ucCRC8 = CRC8_TAB[ucIndex];
    }
    return ucCRC8;
}
```"
"什么是函数指针与回调函数？请举例说明它们的用法。","```c
// 回调函数案例1
int callback_1(void) {  //回调函数1主体
printf(""call_1\n"");
return 0;
};
int callback_2(void) {  //回调函数2主体
printf(""call_2\n"");
return 0;
};
//定义一个处理函数，传入的是函数指针
int Handle(int (*callback)(void)) {
callback();  // 调用函数
}
int main()
{
//定义两个函数指针来指向函数地址
//不定义也可以，因为函数名称本身就是函数入口地址
int (*call1)(void) = &callback_1;
int (*call2)(void) = &callback_2;
Handle(call1);  // 函数指针当参数调用
Handle(call2);
call1();  // 也可直接调用
//改变函数指针指向
call1=&callback_2;
Handle(call1);
return 0;
}
```

```c++
int max(int a, int b) {
return a > b ? a : b;
}
int min(int a, int b) {
return a < b ? a : b;
}
int (*f)(int, int); // 声明函数指针，指向返回值类型为int，有两个参数类型都是int的函数
int main(int argc, _TCHAR* argv[])
{
f = max; // 函数指针f指向求最大值的函数max
int c = (*f)(1, 2);
printf(""The max value is %d \n"", c);
f = min; // 函数指针f指向求最小值的函数min
c = (*f)(1, 2);
printf(""The min value is %d \n"", c);
return 0;
}
```

```c
// 结构体封装函数指针
struct DEMO
{
int x,y;
int (*func)(int,int); //函数指针
};
int add2(int x,int y)
{
return x+y;
}
void main()
{
struct DEMO demo;
demo.func = &add2;  //结构体函数指针赋值
demo.func = add2;  //这样写也可以
int ans = demo.func(3,4);  // 调用
}
```"
"如何理解和使用双指针数组`int **a[3][4]`？","```c++
// 示例1：指针数组与双指针数组的大小计算
int *z[3];
int **zz[3][4];
std::cout << sizeof(z) << std::endl;  // 输出 3*8=24 
std::cout << sizeof(zz) << std::endl; // 输出 4*24=96

// 示例2：一维指针数组的使用
`int *array[10];`
函数声明：`void fun(int *a[10]);`
函数调用：`fun(array);`
访问方法：使用`*(a[i]+j)`访问数组中的元素

// 示例3：二维双指针数组的使用
`int **array[10][20];`
函数声明：`void fun(int **a[10][20]);`
函数调用：`fun(array);`
访问方法：
1. `(*(a+i) + j)`
2. `a[i][j]`（使用双重指针表示的二维数组的访问方法）

参考链接：
[二维数组与双重指针_Ven_J的博客-CSDN博客](https://blog.csdn.net/u013684730/article/details/46565577?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5-46565577-blog-113645091.pc_relevant_recovery_v2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5-46565577-blog-113645091.pc_relevant_recovery_v2&utm_relevant_index=10)
[相关补充文章](https://blog.csdn.net/Arcofcosmos/article/details/113645091)
```"
"什么是结构体字节对齐？它的作用是什么？","字节对齐的作用就是**规定数据在内存中的存储起始地址必须是某个特定字节数（通常是数据类型的大小）的整数倍**。"
"什么是联合体(union)？它有什么特点？","在同一地址空间中存储不同类型的数据
```c
typedef union test_u{
int a;
char b;
}test;
test t;
t.a = 0x12345678;
if(t.b == 0x78) {
printf(""小端\n"");  // 低地址0x00000000 放低字节0x78
}
else {
printf(""大端\n"");  // 低地址0x00000000 放高字节0x12
}
```"
"什么是变长结构体？在C++中如何实现变长结构体？","在C++中，变长结构体可以通过以下两种方式实现：

1. **使用指针成员**：
```c++
struct s_one {
    int s_one_cnt;
    char* s_one_buf;  // 用指针指向不定长buf
};
```

2. **使用长度为0的数组**：
```c++
struct s_two {
    int s_two_cnt;
    char s_two_buf[0];  // 用数组指向不定长buf
};
```

关键区别：
- `sizeof(s_one)` = 8（包含指针大小）
- `sizeof(s_two)` = 4（0长度数组不占空间）

内存分配示例：
```c++
// 指针方式需要两次分配
s_one* p_sone = (s_one*)malloc(sizeof(s_one));
p_sone->s_one_buf = (char*)malloc(1 + ntmp_buf_size);

// 0长度数组方式只需一次分配
int ntotal_stwo_len = sizeof(s_two) + (1 + ntmp_buf_size);
s_two* p_stwo = (s_two*)malloc(ntotal_stwo_len);
```

释放时的区别：
```c++
// 指针方式需要释放两次
free(p_sone->s_one_buf);
free(p_sone);

// 0长度数组方式只需释放一次
free(p_stwo);
```

优势：
- 0长度数组方式内存连续，访问效率更高
- 释放更简单，只需一次操作
- 可直接通过数组名访问，无需指针解引用"
"什么是大小端模式？STM32采用哪种模式？","- **大小端定义**：  
  - **大端模式**：高位字节存储在低地址（如 `0x12345678` 存储为 `12 34 56 78`）。  
  - **小端模式**：高位字节存储在高地址（如 `0x12345678` 存储为 `78 56 34 12`）。  
- **STM32**：采用小端模式，低地址存放数据低位（如 `0x12345678` 在内存中从低到高排列为 `78 56 34 12`）。"
"什么是 C++ 中的 `register` 关键字？它的作用是什么？","在 C++ 中，`register` 是一种关键字，用于建议编译器将变量存储在寄存器中，以提高访问速度。然而，需要注意的是，自 C++11 标准开始，`register` 关键字已经被弃用，编译器会忽略该建议。  

在早期的 C++ 标准中，`register` 关键字可以用于声明变量，以提示编译器将其存储在寄存器中。寄存器是位于 CPU 内部的一种高速内存，可以更快地访问其中的数据，而不需要像访问内存地址那样的开销。通过存储在寄存器中，可以提高对变量的访问速度，从而提高程序的性能。  

使用 `register` 关键字声明变量并不意味着变量一定会被存储在寄存器中，它只是向编译器提出了一个建议。编译器会根据具体的情况（如寄存器的可用性、变量的作用域等）决定是否将变量存储在寄存器中。如果编译器无法满足这个要求，那么该变量将按照通常的方式存储在内存中。  

然而，需要注意的是，现代的编译器已经非常智能化，能够基于自身的优化算法和对代码的分析，自动决定何时将变量存储在寄存器中，而无需开发人员使用 `register` 关键字进行提示。因此，即使使用 `register` 关键字，编译器也可以忽略它，根据自身的优化策略来选择最佳的存储方式。  

综上所述，`register` 关键字是一种用于建议编译器将变量存储在寄存器中的关键字，但自 C++11 标准开始已经被弃用，编译器会忽略它。现代编译器已经能够自动进行寄存器分配和优化，所以在实际编程中不再需要使用 `register` 关键字。  

---"
"静态链接与动态链接的区别是什么？","**静态库在链接阶段的进行组合，动态库在运行时加载**  
静态链接生成的可执行文件体积较大，消耗内存，如果所使用的静态库发生更新改变，程序必须重新编译  

- 静态库的链接是将整个函数库的所有数据在编译时都整合进了目标代码，最小单位是文件，因此**空间浪费，更新困难**  
- 动态库的链接是程序执行到哪个函数链接哪个函数的库  

动态链接库编译时的操作：  
我们在形成可执行程序时，发现引用了一个外部的函数，此时会检查动态链接库，**发现这个函数名是一个动态链接符号**，此时可执行程序就**不对这个符号进行重定位**，而把这个过程留到装载时再进行。  

1. 静态链接（Static Linking）：  
- 在编译时将所有的函数和库代码合并成一个可执行文件。  
- 链接是在编译段完成的，链接库和目标代码中提取所需的函数和库代码，将它们合并到最终的执行文件中 - 链接结果是一个独立的、完的可执行文件，包含了所有依赖的函数和库代码。  
- 优点：  
- 执行速度快，为所有代码已经被编译和链接在一起，无需运行时动态加载额外的库文件。  
- 可执行文件独立，可以在没有安装相应库文件的系统上运行。  
- 缺点：  
- 可执行文件较，因为所有依赖的函数和库代码都被静态链接到可执行文件中。  
- 更新和替换依赖的函数和库代码需要重新编译和链接整个程序。  

2. 动态链接（Dynamic Linking）：  
- 在运行通过动态链接库在内存中加载所需的函数和库代码。  
- 链接是在运行时完成的，链接器在运程序时动态加载所需的函数和库代码。  
- 链接结果是一个可执行文件和一个或多个动态链接库，可执行文件只包含必要的启动代码和符号引用。  
- 优点：  
- 可执行文件较小，因为只包含必要的启动代码和符号引用。  
- 动态链接库可以在多个可文件之间共享，节省内存空间。  
- 更新和替换依赖的函数和库代码只需要替换对应的动态链接库。  
- 缺点：  
- 相对于静态链接，运行时需要额外的时间加载和解析动态链接库。 -中必须存在相应的动态链接库文件，否则程序无法运行。  

总说，静态链接将所有的函数和库代码合并到一个可执行文件中，执行速度快，但可执行文件较大；而动态链接在运行时加载所需的函数和库代码，可执行文件较小，但可能需要额外的加载时间依赖系统存在相应的动态链接库文件。选择使用哪种方式取决于项目的需求和考虑的因素。"
"什么是CRC校验？","循环冗余校验"
