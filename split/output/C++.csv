问题,答案
"可以用malloc给一个类对象分配内存吗？","malloc分配内存不会调用构造函数"
"什么是深浅拷贝？它们之间有什么区别？","- 浅拷贝就是增加了一个指向相同堆区的指针，这将导致在析构的时候会重复释放。默认的拷贝构造和运算符重载都是浅拷贝。  
- 深拷贝是在拷贝的时候将内容申请内存，重新拷贝一份，放到内存中，指针指向这个新拷贝的部分，这样就不会出现析构的时候重复释放的问题了。"
"new与delete的实现原理是什么？","- new和delete实际调用malloc与free，但有以下区别：  
  - 申请失败后，new会抛出异常（bad_malloc），而malloc返回NULL  
  - 对于内置数据类型，行为一致；对于类，new会执行构造函数，delete会执行析构函数  
- new底层实际通过brk()和mmap()系统调用实现内存分配"
"什么是重载和重写？","**重载**：  
- 在同一个类中，方法相同，参数数量与类型不同（静态多态性）。  
- 例：构造函数，函数名相同，参数不同（返回值无法判断）。  

**重写**：  
- 在父类与子类中，方法与参数都相同（动态多态性）。  
- 子类对象调用该方法时，父类方法被屏蔽。"
"new和malloc有什么区别？","| 区别点       | new                                      | malloc                               |
| ------------ | ---------------------------------------- | ------------------------------------ |
| 语法         | `int *p = new int(0)`或`int *p = new int` | `int *p = (int*)malloc(sizeof(int))` |
| 初始化       | 可以初始化                               | 无                                   |
| 函数与运算符 | 操作符，返回指定类型的地址，不需类型转换 | 函数，返回void *                     |
| 失败返回值   | 抛出异常`bad_alloc`                      | 返回NULL                             |
| 构造析构调用 | 创建对象时自动调用                       | 无                                   |"
"什么是模板类？请给出一个C++模板类的示例及其使用方法。","```c++
// XX.h
template <typename T>
class MyTemplateClass {
private:
    T data;
public:
    MyTemplateClass(T value) : data(value) {}  // 构造函数
    void printData() {
        std::cout << ""Data: "" << data << std::endl;  // 模板类方法
    }
};

// XX.cpp
MyTemplateClass<int> obj1(10);   // 实例化为处理int类型的对象
MyTemplateClass<double> obj2(3.14);   // 实例化为处理double类型的对象
obj1.printData();    // 输出: Data: 10
obj2.printData();    // 输出: Data: 3.14
```"
"含有纯虚函数的类是否可以实例化？","不可以，需要被派生类继承后才行。  
在基类中不能对虚函数给出具体的有意义的实现，就可以把它声明为纯虚函数，它的实现留给该基类的派生类去做。  

```c++
class VirtualClass{
public:
    virtual void fun1() = 0;  // 纯虚函数
    virtual ~VirtualClass();
};

class ClassA : public VirtualClass{
public:
    virtual void fun1() {  // 虚函数
        printf(""VirtualClass\n"");
    };
    virtual ~VirtualClass();
};

int main(){
    //编译报错，这个非法的
    VirtualClass * virtualClass = new VirtualClass(); //error: cannot allocate an object of abstract type 'VirtualClass'
    VirtualClass * classA = new ClassA();
    classA->fun1();
    return 0;
}
```"
"指针与引用在C++中有什么区别？","- **指针**：指向一个对象后，对它所指向的变量进行间接操作。  
- **引用**：是目标变量的别名，直接操作目标变量。  

```c++
int a = 996;
int *p = &a; // p是指针, &在此是求地址运算
int &r = a; // r是引用, &在此起标识作用
```

1. **初始化要求**：引用必须初始化，指针不用。  
2. **修改性**：引用初始化后不能修改，指针可以改变所指对象。  
3. **自增操作**：指针++为地址，引用++为值。  
4. **sizeof结果**：sizeof 指针为指针大小，sizeof 引用为数据大小。  

- **指针转换为引用**：通过`*p`解引用，随后作为参数传入即可。  
- **引用转换为指针**：通过`&`取引用对象的地址即可。"
"构造函数是否可以是虚函数？析构函数为什么建议是虚函数？","- 构造函数不可以是虚函数。如果构造函数是虚函数，那么调用构造函数就需要去找vptr（虚函数表指针），而此时vptr还没有初始化。  
- 析构函数需要是虚函数的原因：  
  当父类指针指向子类对象时，释放子类对象时，若父类析构函数非虚，会只调用父类析构函数，子类相较于父类多出的部分不会被析构。  

示例代码：  
```c++
BaseClass* pObj = new SubClass();
delete pObj;
```  

- 若析构函数是虚函数（即加上`virtual`关键词），`delete`时基类和子类都会被释放。  
- 若析构函数不是虚函数（即不加`virtual`关键词），`delete`时只释放基类，不释放子类，会**造成内存泄漏**问题。"
"什么是内存泄漏？如何避免内存泄漏？","内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果  

避免内存泄露的方法  
- 有良好的编码习惯，动态开辟内存空间，及时释放内存  
- 采用智能指针来避免内存泄露  
- 采用静态分析技术、源代码插装技术等进行检测"
"什么是左值引用和右值引用？","- **左值**是指表达式后可以获取地址的对象。换句话说，左值代表一个可以放在等号左边的值，也可以被修改。例如，变量、数组元素和通过引用或指针访问的对象都是左值。  
  ```c++
  int a = 10; // 其中 a 就是左值
  ```  

- **右值**是指表达式后不可以获取地址的临时对象或字面量。右值代表一个临时值，它只能放在等号右边，不能被修改。例如，数字常量、字符串常量、临时变量、返回的临时对象都属于右值。  
  ```c++
  int a = 10; // 其中 10 就是右值
  ```  

C++11引入了**右值引用（rvalue reference）**的概念，允许程序员更方便地对右值进行操作和移动语义，例如移动语义的实现和完美转发。右值引用通过`&&`表示。  
```c++
int&& r = 42; // 创建一个右引用
```"
"为什么模板类需要写在.h文件中，而不是.cpp文件中？","在C++中，模板类需要在头文件（.h）中定义和实现，而非分离到.cpp文件中，原因如下：  

1. **编译时实例化特性**：  
   模板是在编译时根据具体类型实例化的，编译器需要知道模板参数的具体类型才能生成对应的代码。若将声明和定义分离（如放到.cpp中），编译器在编译阶段无法获取模板实现的完整信息，导致无法实例化。  

2. **头文件的解决方案**：  
   将模板的定义和实现全部写入头文件，可确保编译器在编译阶段能访问完整代码，从而为每个模板参数生成正确的实例化代码。  

3. **分离编译的问题**：  
   若模板声明与实现分离，编译阶段仅能看到模板声明，无法生成实例化代码。这会导致链接阶段找不到实例化后的代码，引发链接错误。  

**关键点总结**：  
- 模板实例化依赖编译时的完整定义。  
- 头文件保证编译器能“看到”所有实现细节。  
- 分离到.cpp会破坏模板的实例化机制。"
"shared_ptr在多线程环境下的安全性如何？","- 同一个shared_ptr被多个线程“读”是安全的；  
- 同一个shared_ptr被多个线程“写”是不安全的；  
- 共享引用计数的不同的shared_ptr被多个线程”写“ 是安全的；  
- 引用计数本身是线程安全的，但在多个线程中对其进行修改不安全  

参考资料：  
[shared_ptr是线程安全的吗？-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1654442)  
[当我们谈论shared_ptr的线程安全性时，我们在谈论什么？ - 掘金 (juejin.cn)](https://juejin.cn/post/7038581008945872927)"
"什么是红黑树？","非严格的平衡搜索二叉树，有自动排序的功能"
"deque的底层数据结构是什么？","![20201210223715833.png](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/20201210223715833.png)"
"什么是同步I/O与异步I/O？它们有什么区别？","同步I/O是指程序在进行输入/输出操作时会阻塞当前线程，直到操作完成才继续执行后续代码（死等）  
异步I/O是指程序在进行输入/输出操作时不会阻塞当前线程，而是继续执行后续代码，并通过回调或者轮询等机制来获取I/O操作的结果（让出权限等待唤醒）  

- 同步I/O简单直观，代码编写相对容易，但会阻塞线程造成资源浪费。  
- 异步I/O能够充分利用系统资源，提高并发性能，但需要处理回调和事件驱动等复杂性。"
"什么是面向对象编程？它与面向流程编程有什么区别？","区别于传统的面向流程，需要抽象出一个类来封装各类方法。  

- **封装**  
  1. 将对象的属性（成员变量）和方法（成员函数）封装到一个类里面，便于管理的同时也提高了代码的复用性。  

- **继承**  
  1. 最大程度保留类和类之间的关系，提高代码复用性，降低代码维护成本。  

- **多态**  
  1. 静态多态：编译时确定，函数重载  
  2. 动态多态：运行时确定调用成员函数的时候，会更具调用方法的对象的类型来执行不同的函数。父类指针调用子类对象  

---"
"static的作用是什么？与C语言的区别有哪些？","static 作用主要影响着变量或函数的**生命周期**，**作用域**，以及**存储位置**。  

### 一、修饰局部变量：（函数内部、{}内部）  
- 变量的存储区域由**栈**变为**静态区**。  
- 变量的生命周期由**局部**变为**全局**。  
- 变量的作用域不变。  

### 二、修饰模块内的全局变量：（静态全局变量）  
- 变量的存储区域在全局数据区的**静态区**。  
- 变量的作用域由**整个程序**变为**当前文件**。（extern声明也不行）（全局变量不暴露）  
- 变量的生命周期不变。  

### 三、修饰函数：（当前文件中的函数）  
- 函数的作用域由**整个程序**变为**当前文件**。（extern声明也不行）（接口不暴露）  

### 四、修饰C++ 成员变量  
- 在类外定义与初始化`int A::_count = 0;`，类内申明`static int _count;`  
- 为该类所有对象所共享  
- 访问：类名::变量名  

### 五、修饰C++ 成员函数  
- 没有隐藏的 `this` 指针，不能访问非静态成员（变量、 函数）  
- 不能调用非静态成员函数  
- 非静态成员函数可以调用静态成员函数"
"什么是菱形继承问题？在C++中如何解决菱形继承导致的方法调用不确定性问题？","菱形继承问题指的是在多继承场景下，派生类可能通过不同路径多次继承同一个基类，导致方法调用时出现歧义。

示例代码展示的问题：
```c++
class Animal{
private:
int weight;
public:
virtual int getWeight() {
return this->weight;  // 共用虚函数
}
};
class Tiger :  public Animal{};
class Lion : public Animal{};
class Liger : public Tiger, public Lion{};  // 如此定义存在问题，不确定调用哪个getWeight()
int main()
{
Liger lg;
lg.getWeight();  // 非法
lg.Lion::getWeight();  // 合法
}
```

解决方案（使用虚继承）：
```c++
class Animal{
private:
int weight;
public:
virtual int getWeight() {
return this->weight;
}
};
class Tiger : virtual public Animal{};  // 加入virtual虚继承
class Lion : virtual public Animal{};
class Liger : public Tiger, public Lion{};
int main()
{
Liger lg;
lg.getWeight();
}
```

关键点：
1. 菱形继承会导致派生类包含多个基类子对象
2. 直接调用基类方法会产生歧义
3. 通过虚继承可以确保只保留一个基类子对象
4. 虚继承使用`virtual`关键字修饰继承关系"
"`is_sorted_until()` 函数的作用是什么？如何使用它？","```c++
bool func(int a, int b) {
return a > b;
}
auto it = is_sorted(vec.begin(), vec.end(), func())  // 返回值：指向序列中第一个破坏 comp 排序规则的元素迭代器
```"
"partial_sort()函数的作用是什么？如何使用它进行部分元素的排序？","```c++
partial_sort()用于对容器中的部分元素进行升序或降序排列，利用大顶堆或小顶堆实现，堆空间为n。

示例代码：
bool func(int a, int b) {
return a > b;
}
int n = 4;  // 需要排序的数量
partial_sort(vec.begin(), vec.begin() + n, vec.end(), func);  // 仅排序其中的n个元素
```"
"虚函数的作用及底层实现原理是什么？","1. **实现多态性**  
2. **公有继承**（基类定义虚函数，派生类可以重写）  
3. **动态联编**（父类指针指向子类对象时，调用子类方法）（类似函数重载（静态），重写为动态的）  

```c++
//Base Class
class Student {
private:
int m_id;
// protected:
string m_name;
int m_gender;
public:
Student();
Student(string name, int gender, int id);
virtual ~Student();  //申明virtual方法的基类中的析构函数必须为虚函数，否则在释放指针指向的派生类对象时，将调用基类的析构函数造成错误
virtual void Show_Info();
};
//Derived Class
class Student_Zju : public Student{
private:
int m_ser_num;
public:
Student_Zju();
Student_Zju(string name, int gender, int id, int ser_num);
virtual ~Student_Zju();
virtual void Show_Info();
};
```

**实现机制**：为每个类对象添加一个隐藏成员，保存了一个指向函数（虚函数）地址数组的指针，称为虚表指针（虚函数表）  
- 如果派生类重写了基类的虚方法，该派生类虚函数表将保存重写的虚函数的地址，而不是基类的虚函数地址。  
- 如果基类中的虚方法没有在派生类中重写，那么派生类将继承基类中的虚方法，而且派生类中虚函数表将保存基类中未被重写的虚函数的地址。注意，如果派生类中定义了新的虚方法，则该虚函数的地址也将被添加到派生类虚函数表中。"
"`sort()`函数支持哪些数据结构进行快速排序？如何使用`sort()`函数进行升序排列？","仅支持随机访问的数据结构进行快速排序，如`vector`、`deque`、`array`  
```c++
bool func(int a, int b) {
return a > b;
}
sort(vec.begin(), vec.end(), func);  // 升序排列
```"
"什么是迭代器？","作用：对于不同的数据结构，通过迭代器均可实现遍历，多态  
**[注意]：迭代器只能前进不能后退**"
"什么是虚函数表与内存模型？","假如一个类有虚函数，当我们构建这个类的实例时，将会额外分配一个指向该类虚函数表的指针，当我们用父类的指针来操作一个子类的时候，这个指向虚函数表的指针就派上用场了，它指明了此时应该使用哪个虚函数表  
[C++虚函数表的位置——从内存的角度 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/563418849)  

1. 每个类,只要含有虚函数,new出来的对象就包含一个虚函数指针,指向这个类的虚函数表(这个虚函数表一个类用一张)  
2. 子类继承父类,会形成一个新的虚函数表,但是虚函数的实际地址还是用的父类的,如果子类重写了某个虚函数,那么子类的虚函数表中存放的就是重写的虚函数的地址  
3. 不同类之间可以通过强制转型调用其他类的虚函数"
"C++中如何使用`find()`函数在vector中查找元素？","```c++
vector<int> vec{ 10,20,30,40,50 };
auto it = find(vec.begin(), vec.end(), 30);  // 起始、终止迭代器、查找的值
if (it != myvector.end())
cout << ""查找成功："" << *it;
else
cout << ""查找失败"";
return 0;
```"
"如何判断一个方法来自父类还是子类？","方法一：可以在父类或子类的相应方法中`print()`一个标记。  

方法二：使用`dynamic_cast`进行类型转换判断。  
```c++
class Tfather {
public:
    virtual void f() { cout << ""father's f()"" << endl; }
};
class Tson : public Tfather {
public:
    void f() { cout << ""son's f()"" << endl; }
    int data; // 我是子类独有成员
};
int main() {
    Tfather father;
    Tson son;
    son.data = 123;
    Tfather *pf;
    Tson *ps;

    /* 上行转换：没有问题，多态有效 */
    ps = &son;
    pf = dynamic_cast<Tfather *>(ps);
    pf->f();

    /* 下行转换（pf实际指向子类对象）：没有问题 */
    pf = &son;
    ps = dynamic_cast<Tson *>(pf);
    ps->f();
    cout << ps->data << endl;        // 访问子类独有成员有效

    /* 下行转换（pf实际指向父类对象）：含有不安全操作，dynamic_cast发挥作用返回NULL */
    pf = &father;
    ps = dynamic_cast<Tson *>(pf);
    assert(ps != NULL);              // 违背断言，阻止以下不安全操作
    ps->f();
    cout << ps->data << endl;        // 不安全操作，对象实例根本没有data成员

    /* 下行转换（pf实际指向父类对象）：含有不安全操作，static_cast无视 */
    pf = &father;
    ps = static_cast<Tson *>(pf);
    assert(ps != NULL);
    ps->f();
    cout << ps->data << endl;        // 不安全操作，对象实例根本没有data成员
    system(""pause"");
}
```"
"`is_sorted()`函数的作用是什么？如何使用它来检查容器是否按照自定义顺序排序？","```c++
bool func(int a, int b) {
    return a > b;
}
bool result = is_sorted(vec.begin(), vec.end(), func())  // 返回值为bool，是否按照func定义的顺序排序
```

解释：
1. `is_sorted()`用于检查指定范围内的元素是否已排序
2. 可以通过自定义比较函数`func`来定义排序规则（示例中按降序检查）
3. 返回`bool`值表示是否满足排序条件"
"C++如何实现只在栈上实例化对象？","```c++
// 方法1：只在堆(heap)上建立对象
class A {
protected:
    A(){}
    ~A(){}
public:
    static A* create() {
        return new A();
    }
    void destory() {
        delete this;
    }
};
```

```c++
// 方法2：只在栈(stack)上建立对象
class A {
private:
    void* operator new(size_t t){}     // 注意函数的第一个参数和返回值都是固定的
    void operator delete(void* ptr){}  // 重载了new就需要重载delete
public:
    A(){}
    ~A(){}
};
```

关键原理：  
1. 通过禁用`new`运算符（将其设为私有）来强制对象只能栈分配  
2. 只有使用`new`运算符时对象才会建立在堆上  
3. 需要同时重载`operator new`和`operator delete`  

参考链接：  
[如何限制对象只能建立在堆上或者栈上](https://blog.csdn.net/szchtx/article/details/12000867?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-12000867-blog-61196943.pc_relevant_multi_platform_whitelistv4&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-12000867-blog-61196943.pc_relevant_multi_platform_whitelistv4&utm_relevant_index=1)"
"C++中find_if()函数的作用是什么？如何使用自定义谓词进行查找？","```c++
bool mycomp(int i) {
return ((i % 2) == 1);
}
vector<int> myvector{ 4,2,3,1,5 };
auto it = find_if(myvector.begin(), myvector.end(), mycomp());
```

find_if()函数的作用是按照自定义谓词查找容器中的元素。  
使用步骤：
1. 定义一个返回bool类型的谓词函数（如示例中的mycomp）
2. 在find_if()的参数中传入容器的迭代器范围和谓词函数
3. 函数会返回第一个使谓词返回true的元素的迭代器

示例中查找的是vector中第一个奇数元素（3）。"
"使用vector时如何避免频繁的内存重新分配？","内存分配的过程：  
1. 分配新的内存块，在大部分实现中，vector和string的容量每次以2为因数增长。也就是说，当容器必须扩展时，它们的容量每次翻倍。  
2. 把所有元素从容器的旧内存拷贝到它的新内存。  
3. 销毁旧内存中的对象。  
4. 回收旧内存。  

解决方案：  
1. 预分配内存：在创建 vector 对象时，可以使用 reserve() 方法来预分配内存空间，以避免频繁扩容。  
2. 合理选择初始容量：在创建 vector 对象时，可以根据数据量的大小估算出合理的初始容量，这样可以尽可能减少扩容的次数。  
3. 优化算法：尽可能使用时间复杂度低的算法，避免数据量过大时的性能问题。"
"当两个对象映射到同一个哈希地址时，是否说明这两个对象相同？","当两个对象产生哈希冲突时，它们被映射到了相同的哈希地址上，但并不能确定它们的内容是否相同。两个不同的对象完全可以具有相同的哈希值，因为哈希值只是一个对输入对象进行计算得出的结果。  
要确定两个对象是否相同，通常需要使用其他方法，如比较它们的内容、引用或标识符等。哈希地址相同并不代表对象相同，只能说它们在哈希函数中产生了冲突。"
"什么是设计模式中的单例模式？","```
在整个系统生命周期内，保证一个类只能产生一个实例，确保该类的唯一性。成员函数均为static
```"
"如何避免内存泄漏？用过什么智能指针？智能指针的实现原理是什么？","C++没有内存回收机制，每次程序员new出来的对象需要手动delete，流程复杂时可能会漏掉delete，导致内存泄漏。

智能指针：
- **shared_ptr**（引用计数，新增++，过期--，0释放）
- **unique_ptr**（独占式，不允许复制拷贝）（线程安全）
- **weak_ptr**（解决循环引用计数问题）

**循环引用计数**：两个智能指针互相指向对方，造成内存泄漏。需要weak_ptr，将其中的一个指针设置为weak_ptr。（因为weak_ptr没有共享资源，它的构造函数不会引起智能指针引用计数的变化）

```c++
#include <iostream>
#include <memory>  // 头文件
using namespace std;
class A {
public:
A(int count) {  // 构造
_nCount = count;
}
~A(){}  // 析构
void Print() {
cout<<""count:""<<_nCount<<endl;  // 公有方法
}
private:
int _nCount;  // 私有成员变量
};
int main() {
shared_ptr<A> p(new A(10));  // 初始化，堆上新建一个类，p为智能指针
p->Print();  // 调用
return 0;
}
```

```c++
#include <memory>
shared_ptr<int> p = make_shared<int> (100);  // 指针指向一块存放100的地址，推荐使用
shared_ptr<int> p {new int(100)};  // 第二种创建方式
```

```c++
#include <memory>
unique_ptr<int> p = make_unique<int>(100);  // 独占指针
unique_ptr<int> p1(p.release());  // 将p的指向及所有权转移到p1
unique_ptr<int> p1 = std::move(p);  // 同样的
```"
"vector的resize()和reserve()方法有什么区别？","- `resize(Container::size_type n)`强制把容器改为容纳n个元素。调用resize之后，size将会返回n。  
  如果n小于当前大小，容器尾部的元素会被销毁。  
  如果n大于当前大小，新默认构造的元素会添加到容器尾部。  
  如果n大于当前容量，在元素加入之前会发生重新分配。

- `reserve(Container::size_type n)`强制容器把它的容量改为至少n，提供的n不小于当前大小。  
  这一般强迫进行一次重新分配，因为容量需要增加。  
  （如果n小于当前容量，vector忽略它，这个调用什么都不做，string可能把它的容量减少为size()和n中大的数，但string的大小没有改变。）"
"哈希表的基本操作有哪些？请分别说明查找、插入和删除的过程。","1. **查找**：  
   当使用键进行查找时，哈希表会使用键的哈希值来确定其在哈希表中的位置，并进一步比较键的值来判断是否匹配。如果键相同，那么可以通过哈希值直接找到对应的位置，并返回存储在该位置上的值。

2. **插入**：  
   在向哈希表中插入键值对时，哈希表首先会计算键的哈希值，并根据哈希值找到对应的位置。然后，它会检查该位置上是否已经存在相同的键。如果存在相同的键，则可以选择更新现有的值，或者根据具体的实现策略来处理冲突。

3. **删除**：  
   当从哈希表中删除一个键值对时，哈希表会使用键的哈希值来定位该键所在的位置。如果在该位置上找到了匹配的键，就将其从哈希表中删除。"
"什么是哈希表？它的时间复杂度优势是什么？","查表，要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到。我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。"
"什么是内联函数（inline）？它的作用是什么？","作用：将函数入栈出栈的调用开销减少，（将函数展开为代码）。"
"哈希表如何解决键值冲突？","哈希表（散列表）根据(Key value)直接进行访问的数据结构。映射函数叫做散列函数，存放记录的数组叫做散列表。  
哈希值是通过哈希函数计算出来的，通过哈希函数计算出来的哈希值相同，就是哈希冲突，不能完全避免  

解决方案：  
1. 开放定址法：发现冲突后寻找下一个空闲散列表位置  
2. 再哈希法：利用不同的哈希函数再次计算哈希值（多轮）  
3. 链地址法：每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，因而查找、插入和删除主要在同义词链中进行。  
4. 公共溢出区法：冲突放入溢出表"
"迭代器失效的情况有哪些？如何针对不同数据结构处理迭代器失效问题？","迭代器失效分三种情况考虑，也是分三种数据结构考虑，分别为数组型，链表型，树型数据结构。

**数组型数据结构：**  
该数据结构的元素是分配在连续的内存中，insert和erase操作，都会使得删除点和插入点之后的元素挪位置，所以，插入点和删除掉之后的迭代器全部失效，也就是说insert(*iter)(或erase(*iter))，然后在iter++，是没有意义的。  
解决方法：erase(*iter)的返回值是下一个有效迭代器的值。 iter =cont.erase(iter);

**链表型数据结构：**  
对于list型的数据结构，使用了不连续分配的内存，删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器。  
解决办法两种，erase(*iter)会返回下一个有效迭代器的值，或者erase(iter++).

**树形数据结构：**  
使用红黑树来存储数据，插入不会使得任何迭代器失效；删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器.erase迭代器只是被删元素的迭代器失效，但是返回值为void，所以要采用erase(iter++)的方式删除迭代器。

注意：经过erase(iter)之后的迭代器完全失效，该迭代器iter不能参与任何运算，包括iter++,*ite"
"CMake是如何包含文件目录的？","在CMake中，可以通过以下方式包含文件目录：  

```cmake
target_include_directories(test PRIVATE ${YOUR_DIRECTORY})  #添加要包含的目录
set(SOURCES file.cpp file2.cpp ${YOUR_DIRECTORY}/file1.h ${YOUR_DIRECTORY}/file2.h)  #将头文件添加到当前目标的源文件列表中
add_executable(test ${SOURCES})
```

具体说明：  
1. 使用 `target_include_directories` 指定头文件搜索路径，`PRIVATE` 表示仅对当前目标（如 `test`）生效。  
2. 通过 `set` 命令将源文件（如 `.cpp`）和头文件（如 `.h`）统一添加到变量（如 `SOURCES`）中。  
3. 最后用 `add_executable` 生成可执行文件，并传入所有源文件列表。"
"C++11中引入了哪些特性来解决多线程环境下的并发访问问题？","C++11引入了一组原子类型（Atomic Types），用于解决多线程环境下的并发访问问题。原子类型保证了对变量的读写操作是原子的，即不会发生数据竞争。  

```c++
#include <iostream>
#include <atomic>
#include <thread>

std::atomic<int> counter(0);

void incrementCounter() {
    for (int i = 0; i < 1000; ++i) {
        counter.fetch_add(1, std::memory_order_relaxed);
    }
}

int main() {
    std::thread t1(incrementCounter);
    std::thread t2(incrementCounter);
    t1.join();
    t2.join();
    std::cout << ""Counter value: "" << counter << std::endl;
    return 0;
}
```"
"拷贝构造函数与赋值构造函数有什么区别？它们分别在什么情况下被调用？","区别：**赋值时对象是否已经存在**

C++每一个类提供默认的拷贝构造函数，但成员变量涉及指针时，浅拷贝带来问题，需要自定义深拷贝

拷贝构造函数调用的情况：
```c++
// 拷贝构造
Complex c2(c1);  //拷贝构造函数初始化
Complex c2 = c1;  //首次创建对象是初始化，不是赋值语句
void Func(Class a) {balabala}  //调用函数时，Class将实参拷贝构造为形参
// 对象作为函数参数
void func(Class class);
// 函数返回值为一个非引用型对象
return A_class;
// 使用一个对象初始化另一个对象
Clsss a = b;  // （a不存在，需要构造）
// 有参构造函数
Class c(a);  //调用拷贝构造函数
```

重载的赋值运算符调用情况：
```c++
// 赋值构造
Complex c1, c2;  //默认构造函数
c1 = c2 ;  //重载的赋值运算符，已经存在对象，不是拷贝构造
// 运算符重载
A& operator = (const A& other) {}
// 赋值
Class a;
a = b;  // 对象存在，调用赋值
```

示例代码：
```c++
#include <iostream>
class MyClass {
private:
int privateMember;
public:
// 默认构造函数
MyClass() : privateMember(0) {
std::cout << ""Default constructor called."" << std::endl;
}
// 拷贝构造函数
MyClass(const MyClass& other) : privateMember(other.privateMember) {
std::cout << ""Copy constructor called."" << std::endl;
}
// 赋值构造函数
MyClass& operator=(const MyClass& other) {
std::cout << ""Assignment operator called."" << std::endl;
if (this == &other) {
return *this;
}
privateMember = other.privateMember;
return *this;
}
// 获取私有成员的值
int getPrivateMember() const {
return privateMember;
}
// 设置私有成员的值
void setPrivateMember(int value) {
privateMember = value;
}
};
int main() {
MyClass obj1;  // 调用默认构造函数
obj1.setPrivateMember(42);
MyClass obj2 = obj1;  // 调用拷贝构造函数
MyClass obj3;
obj3 = obj1;  // 调用赋值构造函数
std::cout << ""Value of obj1's private member: "" << obj1.getPrivateMember() << std::endl;
std::cout << ""Value of obj2's private member: "" << obj2.getPrivateMember() << std::endl;
std::cout << ""Value of obj3's private member: "" << obj3.getPrivateMember() << std::endl;
return 0;
}
```"
"为什么C++中vector的扩容系数通常选择1.5或2？","[面试题：C++vector的动态扩容，为何是1.5倍或者是2倍_vector扩容_森明帮大于黑虎帮的博客-CSDN博客](https://blog.csdn.net/qq_44918090/article/details/120583540)  
扩容原理为：申请新空间，拷贝元素，释放旧空间，理想的分配方案是在第N次扩容时如果能复用之前N-1次释放的空间就太好了，如果按照2倍方式扩容，第i次扩容空间大小如下：![db4b6319537147d4817bdb43db2709bf.png](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/db4b6319537147d4817bdb43db2709bf.png)  
可以看到，每次扩容时，前面释放的空间都不能使用。比如：第4次扩容时，前2次空间已经释放，第3次空间还没有释放(开辟新空间、拷贝元素、释放旧空间)，即前面释放的空间只有1 + 2 = 3，假设第3次空间已经释放才只有1+2+4=7，而第四次需要8个空间，因此无法使用之前已释放的空间，但是按照小于2倍方式扩容，多次扩容之后就可以复用之前释放的空间了。  
Linux中：内存heap区域被事先分配为2^n大小，以2的倍数扩容可以方便地进行分配  
Win中：内存被free的区域会被系统立即合并，以1.5被分配可以使用被释放的内存"
"如何在C++中实现字符串string与char*之间的相互转换？","```c
// char[] 转 char*
char ch[]=""abcdef"";
char *s = ch;

// char* 转 char[]
char *s=""abcdef"";
char ch[100];
strcpy(ch,s);

// string 转 char[]
string str= ""abcdef"";
char ch[20];
int i;
for( i=0;i<=str.length();i++){
    ch[i] = str[i];
    if(i==str.length()) c[i] = '\0';
}

// char[] 转 string
string str;
char ch[20] = ""abcdef"";
str = ch;

// string 转 char*
string str = ""abcdef"";
const char* p = (char*)str.data();  // data()仅返回字符串内容，而不含有结束符’\0’

string str=“abcdef”;
const char *p = str.c_str();
//使用char * p=(char*)str.c_str()效果相同

string str=“abcdef”+ '\0';
char *p= new char[str.length()+1];
str.copy(p,str.length(),0);  // 要想指针指向内容及地址不改变，使用该方式

// char* 转 string
string str;
char *p = ""abcdef"";
str = p;

char *p = ""abcdef"";
string str;
str.assign(p,strlen(p));  // 要想指针指向内容及地址不改变，使用该方式
```"
"C++11有哪些主要新特性？","- static_assert 编译时断言  
- 新增加类型 long long，unsigned long long，char16_t，char32_t，原始字符串  
- auto  
- decltype  
- 委托构造函数  
- constexpr  
- 模板别名  
- alignas  
- alignof  
- 原子操作库  
- nullptr  
- 显示转换运算符  
- 继承构造函数  
- 变参数模板  
- 列表初始化  
- 右值引用  
- Lambda 表达式  
- override、final  
- unique_ptr、shared_ptr  
- initializer_list  
- array、unordered_map、unordered_set  
- 线程支持库"
"在面向对象编程中，类实例能直接访问哪些类型的成员？","类实例（即类对象）不能直接访问类的 private成员和protected成员，但是能直接访问类的public成员。"
"什么是extern ""C""以及它在C++中的作用是什么？","extern ""C""是C++中的一个关键字，用于指示编译器以C语言的方式处理被修饰的代码。它的主要作用包括：  

1. **兼容性**：  
   C++不能直接调用C编译器编译的代码，但通过`extern ""C""`包裹C代码段，可以实现C++调用C语言代码的功能。  

2. **编译方式**：  
   - C++支持函数重载，编译时会包含函数名和参数类型信息。  
   - C语言不支持函数重载，编译时仅保留函数名。  
   `extern ""C""`会强制编译器按C语言的规则编译代码（不添加参数类型信息）。  

3. **典型用法**：  
   ```c++
   #ifdef __cplusplus  // 如果是C++文件
   extern ""C"" {        // 按C语言方式编译以下代码
   #endif
       // C语言函数声明或实现  
   #ifdef __cplusplus
   }
   #endif
   ```  

4. **实际示例**：  
   - **头文件模板**（防止重复引用和兼容C/C++）：  
     ```c++
     #ifndef __INCvxWorksh
     #define __INCvxWorksh
     #ifdef __cplusplus
     extern ""C""{
     #endif
     // C函数声明
     #ifdef __cplusplus
     }
     #endif
     #endif
     ```  
   - **跨模块调用**：  
     ```c++
     // moduleB.cpp调用C语言模块moduleA
     #ifdef __cplusplus
     extern ""C"" {
     #include ""moduleA.h""  // 按C语言方式引入头文件
     }
     #endif
     ```  

5. **总结**：  
   在C++中，若需调用C语言编写的库文件，通常会用`extern ""C""`包含对应的C头文件，确保编译和链接的正确性。"
"什么是std::move及其作用？","- std::move是一个函数模板，用于将给定的对象表示为右值（或将其转换为右值用它执行的操作是对传入的对象进行强制转换，使其能够被移动而不是复制。通过使用std::move，我们可以显式地表达出我们要对对象进行移动操作，以便在适当的情况下利用移动语义，提高程序的性能。
- 当使用std::move时，我们可以将一个对象的所有权从一个对象转移到另一个对象。在下面的例子中，通过使用std::move，我们将source的所有权转移到了destination，这样我们就可以高效地移动source的内容而不是逐个复制每个元素。例如：
```c++
int main() {
std::vector<int> source = {1, 2, 3, 4, 5};
// 使用std::move将source的所有权转移到destination
std::vector<int> destination = std::move(source);
// source现在为空，已经移动到destination
std::cout << ""Size of source: "" << source.size() << std::endl; // 输出 0    // destination包含原来source元素
std::coutSize of destination: "" << destination.size() << std::endl; // 输出
return 0;
}
```"
"STL常见容器及其内部实现的数据结构有哪些？","```markdown
### vector
- **描述**: 动态分配的数组
- **存储结构**: 顺序，array
- **方法**:
  - v.capacity(); //容器容量
  - v.size(); //容器大小
  - v.at(int idx); //用法和[]运算符相同
  - v.push_back(); //尾部插入
  - v.pop_back(); //尾部删除
  - v.front(); //获取头部元素
  - v.back(); //获取尾部元素
  - v.begin(); //头元素的迭代器
  - v.end(); //尾部元素的迭代器
  - v.insert(pos,elem); //pos是vector的插入元素的位置
  - v.insert(pos, n, elem) //在位置pos上插入n个元素elem
  - v.insert(pos, begin, end);
  - v.erase(pos); //移除pos位置上的元素，返回下一个数据的位置
  - v.erase(begin, end); //移除[begin, end)区间的数据，返回下一个元素的位置
  - reverse(pos1, pos2); //将vector中的pos1~pos2的元素逆序存储

### list
- **描述**: 双向链表
- **存储结构**: 离散
- **方法**:
  - (1) 元素访问：
    - lt.front();
    - lt.back();
    - lt.begin();
    - lt.end();
  - (2) 添加元素：
    - lt.push_back();
    - lt.push_front();
    - lt.insert(pos, elem);
    - lt.insert(pos, n , elem);
    - lt.insert(pos, begin, end);
    - lt.pop_back();
    - lt.pop_front();
    - lt.erase(begin, end);
    - lt.erase(elem);
  - (3)sort()函数、merge()函数、splice()函数：
    - sort()函数就是对list中的元素进行排序;
    - merge()函数的功能是：将两个容器合并，合并成功后会按从小到大的顺序排列;
    - 比如：lt1.merge(lt2); lt1容器中的元素全都合并到容器lt2中。
    - splice()函数的功能是：可以指定合并位置，但是不能自动排序！

### stack
- **描述**: 栈
- **存储结构**: 用list或deque实现

### quque
- **描述**: 队列
- **存储结构**: 用list或deque实现

### deque
- **描述**: 双端队列
- **存储结构**: 分段连续（多个vector连续）
- **方法**:
  - (1) 元素访问：
    - d[i];
    - d.at[i];
    - d.front();
    - d.back();
    - d.begin();
    - d.end();
  - 添加元素：
    - d.push_back();
    - d.push_front();
    - d.insert(pos,elem); //pos是vector的插入元素的位置
    - d.insert(pos, n, elem) //在位置pos上插入n个元素elem
    - d.insert(pos, begin, end);
  - 删除元素：
    - d.pop_back();
    - d.pop_front();
    - d.erase(pos); //移除pos位置上的元素，返回下一个数据的位置
    - d.erase(begin, end); //移除[begin, end)区间的数据，返回下一个元素的位置

### priority_queue
- **描述**: 优先级队列
- **存储结构**: vector

### set
- **描述**: 集合（有序不重复）
- **存储结构**: 红黑树（弱平衡二叉搜索树，二分查找法搜索高效）
- **方法**:
  - s.size(); //元素的数目
  - s.max_size(); //可容纳的最大元素的数量
  - s.empty(); //判断容器是否为空
  - s.find(elem); //返回值是迭代器类型
  - s.count(elem); //elem的个数，要么是1，要么是0，multiset可以大于一
  - begin 返回一个指向集合中第一个元素的迭代器。
  - cbegin 返回指向集合中第一个元素的const迭代器。
  - end 返回指向末尾的迭代器。
  - cend 返回指向末尾的常量迭代器。
  - rbegin 返回指向末尾的反向迭代器。
  - rend 返回指向起点的反向迭代器。
  - crbegin 返回指向末尾的常量反向迭代器。
  - crend 返回指向起点的常量反向迭代器。
  - s.insert(elem);
  - s.insert(pos, elem);
  - s.insert(begin, end);
  - s.erase(pos);
  - s.erase(begin,end);
  - s.erase(elem);
  - s.clear();//清除a中所有元素；

### multiset
- **描述**: 集合（有序可重复）
- **存储结构**: 红黑树

### unordered_set
- **描述**: 集合（无序不重复）
- **存储结构**: hash

### map
- **描述**: 键值对（有序不重复）
- **存储结构**: 红黑树

### multimap
- **描述**: 键值对（有序可重复）
- **存储结构**: 红黑树

### unordered_map
- **描述**: 键值对（无序不重复）
- **存储结构**: hash

### hash_map
- **描述**: 哈希表，类似map，速度更快
- **存储结构**: hash
```"
