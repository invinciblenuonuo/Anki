问题,答案
"什么是虚拟内存？","通过地址转换，使得应用程序运行在连续内存上，且与内核隔离"
"操作系统对内存管理有哪些主要作用？","- 内存分配与回收  
- 采用虚拟内存进行扩容  
- 负责逻辑地址到物理地址的转换  
- 实现内存保护与隔离（应用间、内核隔离）"
"在1G内存的计算机中能否使用malloc申请1.2G的内存？","在操作系统上可以，malloc申请的是虚拟内存，而非实际硬件内存。  
在硬件上不行"
"Linux栈一般多大？","- Linux栈的大小可以在编译内核时进行配置，并且可以根据系统需求进行调整。栈的大小决定了每个线程的可用栈空间大小。  
- 在大多数Linux系统上，默认的栈大小为8MB。但是，这个值并不是固定的，可以通过修改内核参数或使用特定的命令来改变栈的大小。"
"Nor Flash和Nand Flash的主要区别是什么？","- **Nor Flash**：  
  不仅可以存储数据，且可以取指运行(XIR)，也就是MCU给出地址，Nor可以直接返回指令交给MCU去执行，这样不用把指令拷贝到RAM里去执行；  

- **NAND Flash**：  
  仅可用于存储，取值时需要搬运到RAM中"
"什么是内存碎片？内存碎片分为哪些类型？","内存碎片分为内碎片与外碎片  
​		外碎片：还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。  
​		内碎片：已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间；（按固定大小分配给进程）  
产生原因：分配较多不连续的空间后，剩余可用空间被孤立"
"为什么栈从上往下（高地址->低地址）生长？","- 栈的生长方向：指的是入栈方向，从高地址向低地址生长叫做向下生长，或逆向生长。STM32的栈是向下生长  
- 当需要分配新的栈帧时，栈指针将向较低的内存地址方向移动，为新的栈帧分配空间。而当不再需要某个栈帧时，栈指针会向较高的内存地址方向移动，释放该栈帧所占用的内存空间。"
"什么是缺页中断？","为了使得页表不用常驻内存，将页表分为2级管理，1级页表存储页表索引，2级页表存储内存逻辑地址  
当某些页面不在内存中但被访问到时发生缺页中断  
<img src=""https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/image-20230703173202523.png"" alt=""image-20230703173202523"" style=""zoom:50%;"" />"
"逻辑地址如何转换为物理地址？","1. 依据逻辑地址，整除页面大小得到页号，余数为页内偏移量  
2. 判断越界  
3. 通过PCB中保存的页表查询该页存放在哪一块内存（逻辑内存地址）  
4. 通过逻辑内存地址计算实际物理内存地址  
![image-20230703164233310](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/image-20230703164233310.png)"
"什么是数组下标越界？为什么往高地址和低地址越界的结果不同？如何避免数组下标越界？","```c
int arr[5];
arr[-1];  // 可能可以正常执行
arr[5];  // 一定报错
```

由于函数栈的增长方向为高地址->低地址，高地址处存放函数返回信息和比数组先存入的信息，并且数组的存储顺序为下标小的元素在低地址，因此往高地址越界时会改写原本栈中的数据，往低地址越界修改的是空的未使用的栈，可能不出问题。

解决方案：利用assert和迭代器来避免"
"什么是分页管理？","定义：将内存分为大小相等的页框、进程也分为页框，OS将进程的页框一一对应放入内存  
<img src=""https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/image-20230703161633033.png"" alt=""image-20230703161633033"" style=""zoom:50%;"" />  
在进程控制块PCB中存放页表，记录了进程页号和内存块号之间的对应关系  
<img src=""https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/image-20230703162109683.png"" alt=""image-20230703162109683"" style=""zoom:67%;"" />"
"堆和栈的区别是什么？","- **申请方式**：  
  - stack：系统分配与回收（栈内存分配运算内置于处理器的指令集）；  
  - heap：程序员申请与释放。  

- **存储位置与方向**：  
  - stack：高地址—》低地址；  
  - heap：低地址—》高地址。  

- **碎片问题**：  
  - stack无碎片FIFO；  
  - heap存在内外碎片。  

- **存放内容**：  
  - stack：函数返回地址、局部变量的值；  
  - heap：用户定义。  

- **分配方式**：  
  - 栈的动态分配主要是malloc函数实现的，由编译器自动释放；  
  - 堆只有动态分配用new实现，由程序员手动释放。"
"什么是虚拟内存？","虚拟内存是将即将使用的数据装入内存，若内存满了，将不用的数据换入磁盘的技术。  

第一，虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。  

第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。  

第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。"
"请解释程序的装入方式中的绝对装入、静态重定位和动态重定位的区别？","- **绝对装入（编译时确定绝对地址）**  
  - 在编译时确定程序的绝对内存地址。  
  - 在另一台内存配置不同的电脑上可能无法运行。  

- **静态重定位（保存相对地址，读取时转换）**  
  - 编译和链接后，程序以逻辑地址（相对于0地址的相对值）存放。  
  - 地址空间必须连续，读入内存时对所有逻辑地址进行运算，转换为物理地址（发生在读入时）。  

- **动态重定位（保存相对地址，运行时转换）**  
  - 程序读入内存后不直接计算物理地址，实际执行时才将逻辑地址转换为物理地址（发生在调用时）。  

![image-20230701214310764](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/image-20230701214310764.png)  
![image-20230701214850436](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/image-20230701214850436.png)"
"什么是页表？","带有权限属性，放在物理内存中的，用来**记录虚拟内存页与物理页映射关系**的一张表"
"MCU为什么采用XIP（eXecute In Place）的方式在Flash中运行程序，而不是搬运到RAM中？","1. **节省内存空间**：MCU往往具有较小的内存容量，特别是RAM的容量较有限。使用XIP可以避免将程序复制到RAM中造成内存空间的占用，从而节省了宝贵的RAM空间，可以将RAM用于其他需要快速存取的数据。  
2. **成本优势**：RAM往往比Flash的价格更高，因此将程序直接运行在Flash中可以降低系统成本。在MCU中，Flash往往是固化在芯片内部的，而RAM需要额外的外部芯片或部件支持，增加了系统的复杂性和成本。  
3. **提高读取速度**：Flash存储器通常具有较快的访问速度，对于微控制器来说，执行程序时可能已经足够快。在XIP模式下，不需要将程序从Flash复制到RAM，节省了在复制过程中的时间，可以直接在Flash中运行，加快了程序的启动时间和响应速度。  
4. **适用于嵌入式系统**：MCU往往嵌入在一些资源受限、功耗要求较低的嵌入式系统中。使用XIP可以减少对外部RAM的需求，降低功耗，并且提高系统整体的稳定性和可靠性。  

尽管XIP有以上的优势，它仍然存在一些限制和考虑因素，例如访问延迟较高、不适用于频繁写操作的场景等。因此在设计MCU的时候需要综合考虑具体的应用场景和需求来选择合适的存储方案。"
"请解释内存模型中的data、bss、heap和stack区域，并描述它们在Flash和RAM中的存储方式以及初始化过程。","```markdown
- **Flash存储内容**：  
  - Code (.text段)：存放编译后的机器码  
  - RO-data (.ROdata段)：存放只读常量（如 `const uint32_t ro_var = 0x22222222;`）  
  - RW-data (.RWdata段)：存放已初始化的静态/全局变量（如 `int global_var= 123;`），上电时从Flash搬运到RAM  

- **RAM存储内容**：  
  - RW-data：来自Flash的已初始化数据  
  - ZI-data (.bss段)：存放未初始化的全局变量（如 `int global_var;`），启动时自动初始化为0  

- **内存四区**：  
  | 区域       | 方向     | 管理方式               | 示例                     |  
  | ---------- | -------- | ---------------------- | ------------------------ |  
  | 堆(.heap)  | 向下增长 | 程序员手动分配/释放    | `malloc()`动态内存       |  
  | 栈(.stack) | 向上增长 | 编译器自动分配/释放    | 函数局部变量             |  

- **初始化过程**：  
  1. ROM中存储原始数据：RO DATA（常量）、text（代码）、RW DATA  
  2. 上电后：  
     - 将Flash中的RW DATA加载到RAM  
     - 根据启动文件将RAM中的ZI DATA初始化为0  
```"
"malloc的底层实现是怎样的？","调用malloc时，会去内存空闲链表内寻找可分配的空间，并返回首地址指针。  

以RTT为例，内存管理方法可分为以下两类：  

### 一、内存堆管理  
1. **小内存管理**：从整块内存中通过链表寻找空闲内存块（逐一向后寻找匹配空间）  
   ![小内存管理工作机制图](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/08smem_work.png)  

2. **slab**：将整块内存分为多个不同大小的类别（对号入座），适合于大量的、细小的数据结构的内存申请的情况  
   ![slab 内存分配结构图](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/08slab.png)  

3. **memheap**：多个地址不连续内存，将其连接起来使用  
   ![memheap 处理多内存堆](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/08memheap.png)  

### 二、内存池管理  
- **内存池**：类似slab，分配大块内存  
  ![内存池工作机制图](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/08mempool_work.png)  

### 对比：  
| 分配算法 | 优点               | 缺点                         | 使用场景       |  
| -------- | ------------------ | ---------------------------- | -------------- |  
| 内存堆   | 可分配任意大小内存 | 每次均需要查找、容易产生碎片 | 大量细小内存   |  
| 内存池   | 分配高效           | 无法分配小内存               | 块设备大量数据 |"
"什么是内存对齐？为什么需要内存对齐？","内存对齐是指数据在内存中的存储地址与其自身长度成整数倍关系。需要内存对齐的原因包括：  
1. **平台原因(移植)**：不是所有的硬件平台都能访问任意地址上的任意数据；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。  
2. **性能原因**：为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。  

如果一个变量的内存地址正好位于它长度的整数倍，他就被称做自然对齐。如果在 32 位的机器下， char 对齐值为1， short 为2， int，float为4，double 为 8。  

示例代码：  
```c
struct asd1{
char a;
char b;
short c;
int d;
};//8字节
struct asd2{
char a;
short b;
char c
int d;
};//12字节
```  

内存对齐规则：按照`#pragma pack`指定的数值和这个数据成员自身长度中，比较小的那个进行（最后一个char也占用4Byte）。  

示例代码：  
```c
#pragma pack(4)
struct asd3{
char a;
int b;
short c;
float d;
char e;
};//20字节
#pragma pack()
#pragma pack(1)
struct asd4{
char a;
int b;
short c;
float d;
char e;
};//12字节
#pragma pack()
```  

内存对齐示意图：  
![image-20221210183108484](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/image-20221210183108484.png)  
![image-20221210184840436](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/image-20221210184840436.png)"
"什么是FLEX RAM中的TCM？","TCM（Tightly-Coupled Memory）是紧密耦合内存，分为ITCM和DTCM：  
- **ITCM**用于指令存储，**DTCM**用于数据存储，**特点是跟内核速度相同**（如400MHz），而普通片上RAM通常达不到此速度（如200MHz）。  
- 实时性要求高的程序和变量可分别存放在ITCM和DTCM中执行。"
"在标准C库中，malloc/free函数底层是通过哪些系统调用实现的？","在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由brk（C++）sbrk（C），mmap，munmap这些系统调用实现的"
