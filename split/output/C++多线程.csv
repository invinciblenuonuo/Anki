问题,答案
"`pthread_create` 的作用是什么？","创建子线程，并注册回调函数"
"什么是孤儿进程？","父进程释放，子进程还在，内核接管，没有危害"
"什么是`pthread_cancel`？","在主线程中杀死子线程（通过系统调用，延迟杀死线程）"
"`pthread_equal` 的作用是什么？","比较两个线程ID是否一致"
"`pthread_join` 的作用是什么？","在主线程中调用，等待子线程执行完毕后，释放子线程资源，再执行join后的代码"
"什么是守护进程？","- 守护进程（Daemon），也称为后台进程，是一种运行在后台的特殊进程，不受终端控制，也不需要终端的交互。  
- 与前台进程不同（前台进程依赖终端，终端关闭后进程会消失），守护进程通常在系统启动时自动启动，并在系统运行过程中持续执行系统级任务（如监控资源、处理网络请求等）。  
- 它不与用户交互，无需终端，而是在后台静默运行，直到系统关闭或被手动停止。"
"什么是`pthread_detach`？它的作用是什么？","主线程在调用`pthread_detach(子线程ID)`与`pthread_exit(NULL)`后，不用等待Join才可释放子线程资源，在子线程结束运行前，主线程可以执行其他功能，子线程运行结束后资源由OS而非主线程释放  
<img src=""https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/image-20230306212906250.png"" alt=""image-20230306212906250"" style=""zoom:50%;"" />"
"什么是父子进程中的fork()函数及其工作原理？","当一个进程调用 `fork` 函数生成另一个进程，原进程就称为父进程，新生成的进程则称为子进程。

```c++
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main(int argc, char * argv[])
{
int pid;
/* fork another process */
pid = fork();
if (pid < 0)
{
/* error occurred */
fprintf(stderr,""Fork Failed!"");
exit(-1);
}
else if (pid == 0)
{
/* child process */
printf(""This is Child Process!\n"");
}
else
{
/* parent process  */
printf(""This is Parent Process!\n"");
/* parent will wait for the child to complete*/
wait(NULL);
printf(""Child Complete!\n"");
}
}
```

![image-20230704091925404.png](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/image-20230704091925404.png)

可以建立一个新进程，把当前的进程分为父进程和子进程，新进程称为子进程，而原进程称为父进程。fork调用一次，返回两次，这两个返回分别带回它们各自的返回值，其中在父进程中的返回值是子进程的PID，而子进程中的返回值则返回 0。因此，可以通过返回值来判定该进程是父进程还是子进程。"
"C++20中新增的协程是什么？","C++20新增了协程的支持。协程是一种轻量级的并发机制，具有以下特点：  

1. **依赖关系**：  
   - 线程由操作系统内核调度管理，拥有独立的堆栈和上下文。  
   - 协程由程序员显式定义和管理，无操作系统参与调度，依赖运行时环境或特定库实现切换。  

2. **并发性能**：  
   - 线程属于操作系统级并发，可充分利用多核处理器，但创建大量线程可能导致资源消耗过大。  
   - 协程是轻量级的，单线程可运行大量协程，节省线程切换开销。  

3. **切换机制**：  
   - 线程切换需内核完成上下文保存/恢复，涉及用户态与内核态切换。  
   - 协程切换在用户态完成，开销更小，由程序员手动选择切换点保存/恢复状态。  

4. **同步方式**：  
   - 线程通过共享内存或消息传递通信。  
   - 协程通过显式调度和消息传递实现同步，切换是协作性的（需主动让出执行权）。  

**总结**：  
- 线程更底层，适合多核并行，但受系统资源限制且切换开销大。  
- 协程是高级抽象，适合处理大量轻型任务，切换开销小，但需特定运行时支持且无法直接利用多核并行。"
"什么是僵尸进程？","子进程退出后，父进程不知道，此时子进程还占用着资源。  
在 Linux 环境中，我们是通过 `fork` 函数来创建子进程的。创建完毕之后，父子进程独立运行，父进程无法预知子进程什么时候结束。通常情况下，子进程退出后，父进程会使用 `wait` 或 `waitpid` 函数进行回收子进程的资源，并获得子进程的终止状态。但是，如果父进程先于子进程结束，则子进程成为孤儿进程。孤儿进程将被 init 进程（进程号为1）领养，并由 init 进程对孤儿进程完成状态收集工作。而如果子进程先于父进程退出，同时父进程太忙了，无瑕回收子进程的资源，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。"
