问题,答案
"OS中原子操作是如何实现的？","底层通过关闭中断或原子指令（硬件支持）的方式  
Linux通过原子指令"
"内核态和用户态有什么区别？","区别：  
- 运行级别不同  
- 是否可以操作硬件  

用户态切换到内核态的方式：  
- 系统调用  
- 异常  
- 外围设备中断"
"进程上下文切换时需要保存哪些数据？","- PCB  
- CPU通用寄存器  
- 浮点寄存器  
- 用户栈  
- 内核数据结构（页表、进程表、文件表）"
"什么是TLB（Translation Lookaside Buffer）？","页表的cache，也称为快表，属于MMU的一部分"
"什么是共享内存？","共享内存是进程间通信的一种方式。不同进程之间共享的内存通常为同一段物理内存，进程可以将同一段物理内存连接到他们自己的地址空间中，所有的进程都可以访问共享内存中的地址。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。  

- **优点**：访问高效，通信时无需内核接入避免不必要的复制  
- **缺点**：没有同步机制，需要手动设计"
"什么是TCB与PCB？","线程控制块与进程控制块  

**PCB（进程控制块）包含以下内容：**  
- 进程ID  
- 进程状态寄存器  
- 锁、信号量等同步机制与上下文信息  
- 进程优先级、等待时间等其他内存  
- 内存空间范围  
- 线程状态  
- 文件描述符  

**TCB（线程控制块）包含以下内容：**  
- 线程ID  
- 线程状态寄存器  
- 锁、信号量等同步机制与上下文信息  
- 线程优先级"
"RT-Thread中`rt_enter_critical()`和`rt_hw_interrupt_disable()`有什么区别？","```c
rt_enter_critical()  //禁用调度器，不关闭中断，可嵌套调用，深度65535
rt_hw_interrupt_disable()  // 关闭中断，可嵌套调用
```"
"线程上下文切换时需要保存哪些内容？","- TCB信息  
- 寄存器状态：如R0-R3、SP、LR、PC等  
- 程序状态字：如程序处于中断、用户态、内核态等标志位  
- 堆栈：线程执行期间所用的变量等信息  
- 浮点FPU寄存器  
![5b0d565b5e8841d6b76d514ebbf643f6.jpeg](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/5b0d565b5e8841d6b76d514ebbf643f6.jpeg)"
"TLB、页表、Cache、主存之间的访问关系是怎样的？","首先，程序员应该给出一个逻辑地址。通过逻辑地址去查询TLB和页表（一般是同时查询，TLB是页表的子集，所以TLB命中，页表一定命中；但是页表命中，TLB不一定命中），以确定该数据是否在主存中。因为只要TLB和页表命中，该数据就一定被调入主存。如果TLB和页表都不命中，则代表该数据就不在主存，所以必定会导致Cache访问不命中。现在，假设该数据在主存中，那么Cache也不一定会命中，因为Cache里面的数据仅仅是主存的一小部分。"
"什么时候应该使用进程，什么时候应该使用线程？","**多进程：**  
- 优点：进程独立，不影响主程序稳定性，可多CPU运行  
- 缺点：逻辑复杂，IPC通信困难，调度开销大  

**多线程：**  
- 优点：线程间通信方便，资源开销小，程序逻辑简单  
- 缺点：线程间独立互斥困难，线程崩溃影响进程  

**选择策略：**  
- 频繁创建的任务用线程  
- CPU密集型任务用进程  
- IO密集型任务用线程  

**总结：**  
安全稳定选进程，快速频繁选线程"
"什么是任务调度？","![在这里插入图片描述](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70.png)  

（注：原内容为图片，无法直接提取文字信息，故保留图片作为答案的视觉化说明。）"
"什么是子进程？","子进程：父进程执行fork()系统调用，复制出一个和自身基本一致的进程为子进程，随后执行exec()系统调用，父进程执行其他任务"
"Cortex-M3和M4中有哪几种中断屏蔽寄存器？它们分别有什么作用？","Cortex-M3和M4中断屏蔽寄存器有三种：  

1. **PRIMASK**  
   - 设置为1后，关闭所有中断和除了HardFault异常外的所有其他异常，只有**NMI、Reset和HardFault可以得到响应**。  
   ```assembly
   CPSIE I;                                        // 清除PRIMASK（使能中断）
   CPSID I;                                        // 设置PRIMASK（禁止中断）
   ```  

2. **FAULTMASK**  
   - 设置为1后关闭所有中断和异常，包括HardFault异常，只有**NMI和Reset可以得到响应**。  
   ```assembly
   CPSIE F;                        // 清除FAULTMASK
   CPSID F;                        // 设置FAULTMASK
   ```  

3. **BASEPRI**  
   - 可以屏蔽低于某一个阈值的中断。  
   - 设置为n后，屏蔽所有优先级数值大于等于n的中断和异常。Cortex-M的优先级数值越大其优先级越低。"
"阻塞与非阻塞的区别是什么？","阻塞：条件不满足时等待，进入阻塞态直到条件满足被唤醒  
非阻塞：条件不满足时立刻返回，继续执行其他任务"
"什么是死锁？死锁的原因有哪些？","两个或两个以上的进程在，因争夺资源而造成的一种互相等待的现象  

原因：资源不足、分配不当、推进顺序不合适"
"进程可以创建的线程数量由什么决定？","（可用虚拟空间和线程的栈的大小共同决定）一个进程可用虚拟空间是2G，默认情况下，线程的栈的大小是1MB，所以理论上最多只能创建2048个线程"
"为什么进程切换比线程切换慢？","- 进程切换涉及到页表的切换，页表的切换实质上导致TLB的缓存全部失效，这些寄存器里的内容需要全部重写。而线程切换无需经历此步骤。  
- 线程切换涉及到线程栈"
"FreeRTOS中如何关闭中断？","```c
#define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY  // 此宏用来设置FreeRTOS系统可管理的最大优先级，也就是BASEPRI寄存器中存放的阈值。  
// 关中断  
// 向basepri中写入configMAX_SYSCALL_INTERRUPT_PRIORITY,  
// 表明优先级低于configMAX_SYSCALL_INTERRUPT_PRIORITY的中断都会被屏蔽  
static portFORCE_INLINE void vPortRaiseBASEPRI( void )  
{  
uint32_t ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY;  
__asm  
{  
msr basepri, ulNewBASEPRI  
dsb  
isb  
}  
}  
```"
"什么是临界区？","访问公共资源的程序片段，并不是一种通信方式。"
"互斥锁Mutex和自旋锁Spin有什么区别？","- 当加锁失败时，互斥锁用「线程切换」来应对，自旋锁则用「忙等待」来应对  
- 互斥锁：Mutex，独占锁，谁上锁谁有权释放，申请上锁失败后阻塞，不能在中断中调用  
- 自旋锁：Spinlock：申请上锁失败后，一直判断是否上锁成功，消耗CPU资源，可在中断中调用"
"FreeRTOS的任务调度机制是怎样的？","- 系统时钟判断最高优先级任务进行调度  
- 当前任务主动执行taskYIELD()或portYIELD_FROM_ISR()让出CPU使用权"
"RT-Thread如何通过汇编代码实现屏蔽全部中断（仅响应HardFault、NMI、Reset）？","```assembly
;/*
; * rt_base_t rt_hw_interrupt_disable();
; */
rt_hw_interrupt_disable    PROC
EXPORT  rt_hw_interrupt_disable
MRS     r0, PRIMASK
CPSID   I
BX      LR
ENDP
```  

功能说明：  
1. 通过`MRS r0, PRIMASK`保存当前中断状态到寄存器r0  
2. 使用`CPSID I`指令屏蔽全部中断（除HardFault/NMI/Reset外）  
3. 通过`BX LR`返回原调用位置"
"为什么RTOS不使用malloc和free？","- 实现复杂，占用空间较多  
- 并非线程安全操作  
- 每次调用执行时间不确定  
- 内存碎片化  
- 不同编译器适配复杂  
- 难以调试"
"什么是无名管道和有名管道？","进程间通信（IPC）是指操作系统中不同进程之间进行数据交换和共享的机制。无名管道和有名管道都是常见的进程间通信方式。  

1. **无名管道（Unnamed Pipe）**：  
- 无名管道是一种半双工的、只能在具有公共祖先的进程之间使用的通信机制。  
- 创建无名管道时，操作系统会为其分配一个读端和一个写端。  
- 数据通过管道在进程之间单向流动，一端写入数据，另一端从中读取。  
- 无名管道通常用于父子进程之间的通信，可以通过fork()系统调用创建。  
- 无名管道只能用于有亲缘关系的进程之间的通信，无法被其他进程访问。  

2. **有名管道（Named Pipe）**：  
- 有名管道也称为FIFO（First In, First Out），它提供了一种在无亲缘关系的进程之间进行通信的方法。  
- 有名管道通过在文件系统中创建一个特殊类型的文件来实现，该文件具有独立的文件名。  
- 不同进程可以通过打开该文件并对其进行读写来进行通信。  
- 有名管道允许多个进程同时向其中写入数据或者从中读取数据。  
- 有名管道可以被许多不相关的进程使用，提供了一种灵活的进程间通信方式。  

无名管道和有名管道都是通过读写文件描述符来进行通信的。它们在实现上有所差异，适用于不同的场景和需求。"
"在FreeRTOS中如何创建任务？","在堆中通过`pvPortMalloc`分配内存给TCB。"
"任务堆栈的创建方式有哪些？它们有什么区别？","在创建任务时，可以选择动态创建或静态创建。  
- 静态的任务栈在任务结束后无法被回收。  
- 动态的任务栈可以回收。  

![d5276c09e3fed20db0a9025f8a0b755d.png](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/d5276c09e3fed20db0a9025f8a0b755d.png)"
"RT-Thread 是如何实现抢占式调度的？请描述两个不同优先级线程的调度过程。","```
1. 高优先级任务先执行，执行到`rt_thread_mdelay()`调用`rt_thread_sleep()`中的`rt_schedule()`挂起  
2. 调度器介入，寻找到当前最高优先级任务（`t2`）运行  
3. 低优先级任务时间片未到情况下，由于高优先级任务`rt_thread_mdelay()`超时，其定时计数器变化  
4. 下一个节拍周期到达，定时执行`rt_tick_increase()`，调用`rt_timer_check()`中的`timeout_func()`  
5. 由函数指针跳转到`rt_thread_timeout()`，执行其中的`rt_schedule()`  
6. 进入PendSV中断处理函数进行线程上下文切换
```"
"FreeRTOS中的_FROM_ISR有什么作用？","作用：在中断中调用的API，其禁用了调度器，无延时等阻塞操作，保证临界区资源快进快出访问  
RT-Thread中没有类似的API，仅有延时参数选项"
"FreeRTOS中如何设置中断优先级？","在FreeRTOS中，中断优先级的设置涉及以下两个关键宏定义：  

```c
#define configLIBRARY_LOWEST_INTERRUPT_PRIORITY			15       //中断最低优先级(0-15)  
#define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY	5        //系统可管理的最高中断优先级  
```

- **`configLIBRARY_LOWEST_INTERRUPT_PRIORITY`**：设置中断的最低优先级，范围为0-15（数值越大优先级越低）。  
- **`configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY`**：设置FreeRTOS系统可管理的最高中断优先级（数值需小于5）。高于此优先级的中断（优先级数值小于5），FreeRTOS不会管理。  

![20190823151313168.png](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/20190823151313168.png)"
"RTOS堆栈溢出的检测有哪些方案？各自的优缺点是什么？","方案1：在调度时检查栈指针是否越界（任务保存有栈顶和栈大小信息，每次切换时检查栈指针是否越界）  
- 优点：检测较快  
- 缺点：对于任务运行时溢出，而切换前又恢复正常的情况无法检测  

方案2：在调度时检查栈末尾的16个字节是否发生改变（创建任务时初始化为特定字符，每次切换时判断是否被改写）  
- 优点：可检出几乎所有溢出  
- 缺点：检测较慢"
"临界区与锁的对比是什么？","- 互斥锁与临界区的作用非常相似，但互斥锁（mutex）是可以命名的，也就是说它可以跨越进程使用。所以创建互斥锁需要的资源更多，所以如果只为了在进程内部使用的话使用临界区会带来速度上的优势并能够减少资源占用量。因为互斥锁是跨进程的互斥锁一旦被创建，就可以通过名字打开它  
- 临界区是一种轻量级的同步机制，与互斥和事件这些内核同步对象相比，临界区是用户态下的对象，即只能在同一进程中实现线程互斥。因无需在用户态和核心态之间切换，所以工作效率比较互斥来说要高很多。  

|        | 使用场景             | 操作权限           |  
| ------ | -------------------- | ------------------ |  
| 临界区 | 一个进程下不同线程间 | 用户态，轻量级，快 |  
| 互斥锁 | 进程间或线程间       | 内核态，切换，慢   |"
"FreeRTOS中优先级是如何表示的？","高优先级数字大"
"什么是内存池？","内存池是一种用于管理和分配内存的技术。它被用于**解决频繁地申请和释放内存带来的性能问题**。"
"RT-Thread 中消息队列、邮箱、信号量有什么区别？","- **全局变量通信**：可以承载通信的内容，但无法告知接收方数据的到达（需要接收方轮询，占用资源）  
- **信号量**：告知接收方信息到达，但是未告知数据内容  
- **消息队列**：承载了信息内容，同时告知接收方信息到达  
- **邮箱**：4 Byte的通信，通过指针而非`memcpy()`，开销小"
"什么是RT-Thread单元测试？","```
定义：对软件中的最小可测试单元进行检查和验证（函数、方法、类、功能模块）  
utest框架（unit test）
```"
"线程间通信的基本概念是什么？","**进程有独立的地址空间，线程公用地址空间。**  
线程间无需特别的手段进行通信，因为线程间可以共享一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段等，所以线程之间可以方便、快速地共享信息。只需要将数据复制到共享（全局或堆）变量中即可。不过，要考虑线程的同步和互斥。"
"什么是RT-Thread POSIX标准？","Portable operating system interface，保证应用程序在不同OS下的可移植性"
"RTOS优先级分配的原则是什么？","依据任务对响应的敏感性、执行时长（RTOS抢占式，会导致饥饿）  

- 串口接收中断等任务优先级最高  
- 电机PID计算以及控制需要固定控制周期，优先级较高  
- 看门狗，按键处理中等  
- 最低的APP层的心跳和信息显示任务"
"如何在RT-Thread中进行崩溃调试？","使用`CmBacktrace`函数可以在系统崩溃后保存线程栈和寄存器值，便于逆向分析调用关系。  

![image-20221204193728105](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/image-20221204193728105.png)"
"什么是优先级反转？","使用信号量时  
高优先级任务被低优先级任务阻塞，导致高优先级任务迟迟得不到调度。但其他中等优先级的任务却能抢到CPU资源。-- 从现象上来看，好像是中优先级的任务比高优先级任务具有更高的优先权。  
<img src=""https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/mutex002.png"" alt=""查看源图像"" style=""zoom: 50%;"" />"
"RTOS中多线程看门狗有哪些实现方案？","方案1：在最低优先级线程喂狗，若高优先级线程长时间抢占，则看门狗超时  
方案2：监控各线程调度情况，每个线程放置定时任务喂狗，超时则单个线程阻塞"
"RT-Thread内核移植涉及哪些主要内容？","CPU架构移植：  
​		在不同的架构，如RISC-V、Cortex-M上运行，上下文切换，时钟配置以及中断操作等的适配  
BSP移植：  
​		对于同架构CPU，对不同外设进行适配、动态内存管理"
"什么是进程间通信？","**进程有独立的地址空间，线程公用地址空间。**  

| 类别 | 信号   | 信号量           | 消息队列 | 管道                                            | 共享内存                                 | socket         |  
| ---- | ------ | ---------------- | -------- | ----------------------------------------------- | ---------------------------------------- | -------------- |  
| 描述 | 软中断 | 计数器，同步互斥 | 消息链表 | 无名管道（父子进程间通信）+有名管道（FIFO文件） | 将同一块内存映射到不同进程（最快最有效） | 面向网络的通信 |  
| 流向 |        |                  | 单向     | 单向                                            | 双向                                     |                |  

事件不是进程间通信的方式。  

---"
"FreeRTOS的内存管理是如何实现的？","FreeRTOS的内存位于.bss段，并非heap（启动文件中的堆空间大小）。  
使用`pvPortMalloc`函数申请内存时，也是从这个系统堆（实际为bss段）中申请的。  

```c
#define configTOTAL_HEAP_SIZE                        ( ( size_t ) ( 100 * 1024 )   // 申请100KB内存用于RTOS系统堆内存
```

在map文件中可以看到FreeRTOS使用一个静态数组作为HEAP，以我使用的`heap_4.c`内存管理策略来说，它定义在`heap_4.c`这个文件里面。因为这个HEAP来自于静态数组，所以它存在于数据段(具体为.bss段)，并不是我一开始认为的FreeRTOS所使用的HEAP来自于系统的堆。  

```c
.bss                  zero     0x2021'7d1c  0x1'9000  heap_4.o [35]  // 实际位于.bss段
Entry                       Address      Size  Type      Object
-----                       -------      ----  ----      ------
ucHeap                  0x2021'7d1c  0x1'9000  Data  Lc  heap_4.o [35]  // 起始地址与大小
```"
"RT-Thread中有哪些同步互斥与通信的内核对象？它们的特点和用途分别是什么？","| 内核对象      | 生产者 | 消费者    | 数据/状态  | 说明                               |  
| ------------- | ------ | --------- | ---------- | ---------------------------------- |  
| Semaphore     | all    | all       | 数量0~n    | 维护的资源个数                     |  
| Mutex         | A上锁  | 只能A开锁 | bit 0、1   | 单一互斥资源                       |  
| Event         | all    | all       | 多个bit    | 传递事件用以唤醒，实现多任务的同步 |  
| Mail box      | all    | all       | 固定4 Byte | 传递指针                           |  
| Message queue | all    | all       | 若干数据   | 传递数据（结构体）                 |  
| Signal        |        |           |            | 软中断，用以唤醒                   |"
"FreeRTOS中taskENTER_CRITICAL和taskDISABLE_INTERRUPTS有什么区别？","```c
vTaskSuspendAll()  // 挂起调度器。不关中断，属于 FreeRTOS 层面，不直接依赖具体的硬件，可嵌套调用  
taskENTER_CRITICAL  // 支持嵌套调用，底层为关闭部分中断，有引用计数  
taskDISABLE_INTERRUPTS  // 关闭中断，不支持嵌套，实现方式为配置BASEPRI寄存器，屏蔽某些中断  
```

主要区别体现在嵌套行为和中断控制方式：  
1. **嵌套支持**  
   - `taskENTER_CRITICAL`：支持嵌套调用，通过引用计数保证内层退出时不会误开中断。  
   - `taskDISABLE_INTERRUPTS`：不支持嵌套，即使多次调用关闭中断，一次`ENABLE`就会直接恢复中断。  

2. **中断控制范围**  
   - `taskENTER_CRITICAL`：仅关闭部分中断（如配置为关闭优先级低于某个阈值的中断）。  
   - `taskDISABLE_INTERRUPTS`：直接配置`BASEPRI`寄存器屏蔽指定优先级的中断。  

3. **典型问题场景**  
   在以下代码中，`funcB()`中的`ENABLE`会直接打开中断，导致`funcC()`失去保护：  
   ```c
   void funcA()  
   {  
       taskDISABLE_INTERRUPTS(); //关中断  
       funcB();                  //调用函数funcB  
       funcC();                  //此时中断可能已被funcB意外打开  
       taskENABLE_INTERRUPTS();  //开中断  
   }  
   void funcB()  
   {  
       taskDISABLE_INTERRUPTS(); //关中断  
       执行代码  
       taskENABLE_INTERRUPTS();  //开中断（会直接生效，无视外层调用）  
   }  
   ```  
   若改用`taskENTER_CRITICAL`，内层退出时不会立即恢复中断，只有最外层退出才会真正打开中断。"
"FreeRTOS内存管理算法heap_1~5的主要特点是什么？","FreeRTOS提供了五种内存管理算法（heap_1~5），其特点如下：  

1. **heap_1**  
   - 只分配不回收，不合并空闲区块  
   - 优点：时间确定  
   - 缺点：仅支持分配，不支持回收  

2. **heap_2**  
   - 使用最佳拟合算法分配  
   - 回收但不合并，会产生内存碎片  
   - 优点：最佳匹配  
   - 缺点：回收不合并、时间不确定  

3. **heap_3**  
   - 使用标准库`malloc()`和`free()`函数  
   - 内存堆大小由链接器配置定义（启动文件定义）  
   - 优点：兼容标准库  
   - 缺点：代码量大、线程不安全、时间不确定  

4. **heap_4**  
   - 使用首次拟合算法分配  
   - 合并相邻的空闲内存块  
   - 优点：最佳匹配且合并空闲块  
   - 缺点：时间不确定  

5. **heap_5**  
   - 在heap_4的基础上，支持从多个独立的内存空间分配内存  
   - 优点：支持多段不连续RAM  
   - 缺点：时间不确定  

---  
**补充说明**：  
- 除heap_3外，其他算法均在bss段开辟静态空间管理内存，例如：  
  ```c
  // 定义内存堆大小
  #define configTOTAL_HEAP_SIZE (8 * 1024) // 8KB
  // 全局变量定义
  static uint8_t ucHeap[configTOTAL_HEAP_SIZE];
  uint8_t *ucHeap = ucHeap;
  ```  
- 参考链接：  
  [FreeRTOS笔记（六）：五种内存管理详解](https://blog.csdn.net/weixin_43952192/article/details/108189300)  
  [heap_4.c内存管理分析](https://blog.csdn.net/yuanlin725/article/details/115087718)  

![内存管理示意图](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/856ee0739f2c46798c2c3dc3c76ff4c8.png)"
"进程和线程在地址管理上有何区别？","- 进程是资源分配的最小单位，线程是CPU调度的最小单位，进程有独立分配的内存空间，线程共享进程空间  
- 真正在cpu上运行的是线程"
"C++11中的条件变量(condition variable)是什么？它的主要功能和使用方法是什么？","C++11中的条件变量(condition variable)是一种同步机制，当条件不满足时，相关线程会被一直阻塞，直到某种条件出现，这些线程才会被唤醒。

主要功能和使用方法：
- 线程的阻塞是通过成员函数`wait()`/`wait_for()`和`wait_until()`实现
- 线程唤醒是通过函数`notify_all()`和`notify_one()`实现

虚假唤醒问题：
在正常情况下，wait类型函数返回时要么是因为被唤醒，要么是因为超时才返回。但在实际中发现，由于操作系统的原因，wait类型在不满足条件时也可能会返回，这就导致了虚假唤醒。

```c++
if (不满足xxx条件) {
//没有虚假唤醒，wait函数可以一直等待，直到被唤醒或者超时，没有问题。
//但实际中却存在虚假唤醒，导致假设不成立，wait不会继续等待，跳出if语句，
//提前执行其他代码，流程异常
wait();
}
//其他代码
...
// 实际使用：
while (!(xxx条件) )
{
//虚假唤醒发生，由于while循环，再次检查条件是否满足，
//否则继续等待，解决虚假唤醒
wait();
}
//其他代码
....
```

案例：生产者消费者模式
```c++
#include <mutex>
#include <deque>
#include <iostream>
#include <thread>
#include <condition_variable>
class PCModle {
public:
PCModle() : work_(true), max_num(30), next_index(0) {
}
void producer_thread() {
while (work_) {
std::this_thread::sleep_for(std::chrono::milliseconds(500));
//加锁
std::unique_lock<std::mutex> lk(cvMutex);
//当队列未满时，继续添加数据
cv.wait(lk, [this]() { return this->data_deque.size() <= this->max_num; });
next_index++;
data_deque.push_back(next_index);
std::cout << ""producer "" << next_index << "", queue size: "" << data_deque.size() << std::endl;
//唤醒其他线程
cv.notify_all();
//自动释放锁
}
}
void consumer_thread() {
while (work_) {
//加锁
std::unique_lock<std::mutex> lk(cvMutex);
//检测条件是否达成
cv.wait(lk, [this] { return !this->data_deque.empty(); });
//互斥操作，消息数据
int data = data_deque.front();
data_deque.pop_front();
std::cout << ""consumer "" << data << "", deque size: "" << data_deque.size() << std::endl;
//唤醒其他线程
cv.notify_all();
//自动释放锁
}
}
private:
bool work_;
std::mutex cvMutex;
std::condition_variable cv;
//缓存区
std::deque<int> data_deque;
//缓存区最大数目
size_t max_num;
//数据
int next_index;
};
int main() {
PCModle obj;
std::thread ProducerThread = std::thread(&PCModle::producer_thread, &obj);
std::thread ConsumerThread = std::thread(&PCModle::consumer_thread, &obj);
ProducerThread.join();
ConsumerThread.join();
return 0;
}
```"
"RT-Thread是如何通过静态数组管理内存的？","```c
#define RT_HEAP_SIZE 6*1024
/* 从内部SRAM申请一块静态内存来作为内存堆使用 */
static uint32_t rt_heap[RT_HEAP_SIZE];	// heap default size: 24K(1024 * 4 * 6)
```"
"RT-Thread中的普通双向循环链表和RTT中双向循环链表有什么区别？","- 普通双向循环链表：针对每一个数据结构固定的节点进行操作  
- RTT中双向循环链表：数据结构不固定，不依赖于节点数据类型"
"什么是SVC中断及其作用？","SVC（系统服务调用）和 PendSV（可悬挂系统调用）多用于在操作系统之上的软件开发中。  

- SVC 用于产生系统函数的调用请求。  
  例如，操作系统不让用户程序直接访问硬件，而是通过提供一些系统服务函数，用户程序使用 SVC 发出对系统服务函数的呼叫请求，以这种方法调用它们来间接访问硬件。因此，当用户程序想要控制特定的硬件时，它就会产生一个 SVC 异常，然后操作系统提供的 SVC 异常服务例程得到执行，它再调用相关的操作系统函数，后者完成用户程序请求的服务。  

![20200807100320959.png](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/20200807100320959.png)  

系统调用处理异常，用户与内核进行交互，用户想做一些内核相关功能的时候必须通过SVC异常，让内核处于异常模式，才能调用执行内核的源码。触发SVC异常，会立即执行SVC异常代码。  

为什么要用SVC启动第一个任务？因为使用了OS，任务都交给内核。总不能像裸机调用普通函数一样启动一个任务。  

FreeRTOS中任务调度器触发了 `SVC` 中断来启动第一个任务，之后的工作都靠 `PendSV` 和 `SysTick` 中断触发来实现。  

`SVC`是系统服务调用，由 `SVC` 指令触发调用。在 [FreeRTOS](https://so.csdn.net/so/search?q=FreeRTOS&spm=1001.2101.3001.7020) 中用来在任务调度中开启第一个任务。触发指令：`svc 0`  

- `SVC`中断就是软中断，给用户提供一个访问硬件的接口  
- `PendSV`中断相对`SVC`来说，是可以被延迟执行的，用于任务切换  

---"
"RT-Thread中PendSV系统调用的作用是什么？它是如何实现上下文切换的？","- **省流版**：  
  OS调度依赖于systick（最低优先级），ISR抢占OS调度先执行，OS调度在无ISR时实际由PendSV执行。若调度时ISR到来则插队执行ISR，再执行调度。

- **方法1-无PendSV-SysTick最高优先级（Fault异常）**：  
  - 若CPU正在响应ISR时SysTick（更高优先级）抢占ISR，此时SysTick中不能进行上下文切换，否则会导致：  
    1. ISR被延迟（违反实时性要求）  
    2. **IRQ未响应直接执行线程，触发Fault异常**  
  ![图示](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/985d1f704b714f0db46dc11aea1d6516.png)

- **方法2-无PendSV-SysTick最低优先级（无法满足实时）**：  
  - 将SysTick设为最低优先级并在其中切换上下文，但OS调度期间会关闭中断（临界区），导致：  
    - 调度耗时过程中新IRQ无法被快速响应  
  ![图示](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/ce65afff54074fb4b1c11c581cdab6a9.png)

- **实际方案-PendSV+SysTick最低优先级**：  
  - **优化原理**：利用PendSV的【缓期执行】特性，将调度分为两阶段：  
    1. SysTick仅做调度判断（不切换任务）  
    2. 触发最低优先级的PendSV，等待所有高优先级IRQ执行完毕后再切换任务（可被打断）  
  ![图示](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/8619359f18254c73bbdcfe7f524fc9e1.png)  
  - **缺陷**：  
    1. 频繁IRQ可能导致SysTick滞后，节拍不准  
    2. 任务调度速度受影响  

- **SysTick最高优先级的后果**：  
  - 周期性抢占IRQ会导致外部中断响应变慢  
  ![图示](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/183197e37e1146a09eb1012a48ba0f37.png)  

- **具体实现流程**：  
  1. 任务A请求SVC系统调用切换任务  
  2. 内核挂起PendSV异常  
  3. CPU退出SVC后进入PendSV执行切换  
  4. 返回任务B  
  5. 中断发生→执行ISR  
  6. ISR中被SysTick抢占  
  7. PendSV准备切换  
  8. SysTick退出后继续ISR  
  9. ISR完毕→PendSV切换至任务A  
  ![流程图](https://obsidian-1321127127.cos.ap-beijing.myqcloud.com/10pendsv.jpg)"
